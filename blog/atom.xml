<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Regiondavid&#39;s Blog</title>
  <subtitle>something about code , life and thought</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://regiondavid.github.io/blog/"/>
  <updated>2016-10-27T08:57:22.728Z</updated>
  <id>http://regiondavid.github.io/blog/</id>
  
  <author>
    <name>Region David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多种布局的回顾</title>
    <link href="http://regiondavid.github.io/blog/2016/10/22/%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://regiondavid.github.io/blog/2016/10/22/多种布局的探索/</id>
    <published>2016-10-22T01:20:00.000Z</published>
    <updated>2016-10-27T08:57:22.728Z</updated>
    
    <content type="html"><![CDATA[<p>感觉好久没咋写过样式了，手有些生，顺便借整理的机会熟悉一下<br><a id="more"></a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>按布局的尺寸及样式分<ul>
<li><a href="#1">固定布局</a></li>
<li><a href="#2">流体布局</a></li>
<li><a href="#3">响应式布局</a></li>
</ul>
</li>
<li>按布局的层次分<ul>
<li>三栏式布局<ul>
<li><a href="#4">最常规的三段式布局</a></li>
</ul>
</li>
<li>两栏式布局<ul>
<li><a href="#5">左右固定宽度的两栏式布局</a></li>
<li><a href="#6">左栏固定宽度，右栏自适应的布局</a></li>
<li><a href="#7">横向固定宽度的三段式布局</a></li>
<li><a href="#8">左右固定宽度中间自适应的布局方法</a><ul>
<li><a href="#9">自身浮动法</a></li>
<li><a href="#10">通过设置负边距</a></li>
<li><a href="#11">圣杯布局</a></li>
<li><a href="#12">双飞翼布局</a></li>
</ul>
</li>
<li><a href="#13">右栏固定宽度，左栏自适应的布局</a></li>
<li><a href="#14">中间宽度固定，左右自适应的布局</a></li>
</ul>
</li>
</ul>
</li>
<li>几种比较新的布局<ul>
<li><a href="#14">flex布局</a></li>
<li><a href="#15">grid布局</a></li>
</ul>
</li>
<li>未完待续（等以后出新的再补充）</li>
</ul>
<h3 id="固定布局"><a href="#固定布局" class="headerlink" title="固定布局"></a><span id="1">固定布局</span></h3><p>顾名思义，就是页面的宽度都写死，比如 <code>1024px</code> 等。比较典型的例子就是<a href="https://www.douban.com" target="_blank" rel="external">豆瓣网</a>。这样写的好处就是能够保证在不同的设备上显示的都是一样的，并且一些需要精密的效果时可以比较完好的实现。但是也是有不足的。比如当把宽度设为 <code>1920px</code> 时，如果在低分辨率的设备上访问时，就会出现滚动条，影响页面效果。</p>
<p>另一个缺点就是如果在低分辨率下写的比较满的页面，可能在高分辨率下就会出现大面积空白，比较浪费屏幕资源。</p>
<h3 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a><span id="2">流体布局</span></h3><p>为了解决固定布局的弊端，我们很自然的会想到用百分比去设置一些宽高，用 <code>em</code> 或者 <code>rem</code> 去设置字体大小，这就是我们所说的流体布局，也叫自适应布局。流体布局很好的解决了不同分辨率下甚至移动端的体验。</p>
<p>当然缺点也是存在的</p>
<blockquote>
<p>但缺点明显：宽度使用百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。</p>
<p>—— <a href="https://www.zhihu.com/question/21679928" target="_blank" rel="external">流布局与响应式网页设计有什么区别？郑杭的回答</a></p>
</blockquote>
<p>之前也有过类似的感觉，如果用百分比感觉在某个尺寸范围里变化会特别快，然后合在一起的样式就会非常诡异。特别是会出现本来一个宽大于高的块然后在移动端会变成高大于宽的一个块，整体的设计结构就变样了。见下图<br><img src="http://p1.bpimg.com/1949/87a379c1a9562bae.png" alt="Markdown"></p>
<p><img src="http://p1.bqimg.com/1949/c9446690188ecc06.png" alt="Markdown"></p>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a><span id="3">响应式布局</span></h3><p>响应式布局其实就是流式布局+媒体查询，在一定的尺寸内页面内容会按照百分比去缩放，当到达媒体查询设定的值后，会改动一部分内容的样式，以便在移动端获得更好的体验。常见的做法是把导航栏收到一个按钮里，点击之后会以下拉列表的形式展出，或者把与导航栏在一行的搜索框在缩小到一定尺寸后取消掉或者换到下一行，以张鑫旭大神的博客为例，见下图<br><img src="http://p1.bqimg.com/4851/09d534bfab5fbe3c.png" alt="响应式1"><br><img src="http://p1.bqimg.com/1949/bb1f0056eb825687.png" alt="Markdown"></p>
<p>至于在三种布局方式中如何取舍，还是看项目的需求，比如有些部分可以做成固定布局与自适应布局相结合的方式，可能更便于后期的维护。这个还是要靠自己经验的积累。</p>
<h3 id="最常规的三段式布局"><a href="#最常规的三段式布局" class="headerlink" title="最常规的三段式布局"></a><span id="4">最常规的三段式布局</span></h3><p>三段式布局是我们平时最常见到的布局方式。如下图<br><img src="http://i1.piimg.com/1949/8d2c19cf9b7c83eb.png" alt="实例一"><br>头部、身体和尾部很生动的显示出三部分的排列方式，即从上到下依次排列，实现起来也非常简单，写出三个DIV自己就排好了。此处也就不用代码去展示了。</p>
<h3 id="左右固定宽度的两栏式布局"><a href="#左右固定宽度的两栏式布局" class="headerlink" title="左右固定宽度的两栏式布局"></a><span id="5">左右固定宽度的两栏式布局</span></h3><p>这种布局也非常常见，实现方式也有很多，我们一一来尝试。</p>
<ul>
<li>规定好左右的宽度后，利用float浮动来实现</li>
</ul>
<pre><code class="html">    &lt;div class=&quot;box3&quot;&gt;
        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .box3{
            width: 100px;
            height: 300px;
            background-color: #A9A8A8;
        }
        .box1{
            width: 50px;
            height: 200px;
            float: left;
            background-color: #7068EB;
        }
        .box2{
            width: 50px;
            height: 200px;
            float: left;
            background-color: #FF3434;
        }
    &lt;/style&gt;
</code></pre>
<ul>
<li>一个向左浮，一个向右浮<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
      }
      .box1{
          width: 50px;
          height: 200px;
          float: left;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          float: right;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>一个不动，另一个通过绝对定位去移动<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
          position: relative;
      }
      .box1{
          width: 50px;
          height: 200px;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          position: absolute;
          top: 0px;
          left: 50px;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>改成行内元素，然后自然并排到一起<pre><code class="html">  &lt;div class=&quot;box3&quot;&gt;
          &lt;!-- 此处的div2和div3一定要记得把中间的换行符去掉，否则会产生空隙 --&gt;
          &lt;!-- 当然还有其他办法，就不在这说了，可以去看整理的《一点小东西》那篇里有整理 --&gt;
          &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
      }
      .box1{
          width: 50px;
          height: 200px;
          display: inline-block;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          display: inline-block;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>采用 <code>display:table-cell</code><h3 id="左或右固定宽度，另一侧自适应的布局"><a href="#左或右固定宽度，另一侧自适应的布局" class="headerlink" title="左或右固定宽度，另一侧自适应的布局"></a><span id="6">左或右固定宽度，另一侧自适应的布局</span></h3>此处方便起见，仅以左栏固定，右栏自适应为例</li>
<li>让固定高度的浮动，另一个通过 <code>margin</code> 让出距离或者通过BFC去实现（BFC的总结见<a href="">整理的这篇文章</a>）<br>因为不设高度的话，浮动起来会消失掉，也就无意义了<pre><code class="html">  &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      #div1{
          width: 50px;
          height: 200px;
          float: left;
          background-color: #7068EB;
      }
      #div2{
          height: 230px;
          background-color: #FF3434;
          /*margin-left: 50px;*/
          overflow: hidden;
      }
  &lt;/style&gt;
</code></pre>
<h3 id="横向固定宽度的三段式布局"><a href="#横向固定宽度的三段式布局" class="headerlink" title="横向固定宽度的三段式布局"></a><span id="7">横向固定宽度的三段式布局</span></h3>这个不展开说了，方法挺多的<h3 id="左右固定宽度中间自适应的布局方法"><a href="#左右固定宽度中间自适应的布局方法" class="headerlink" title="左右固定宽度中间自适应的布局方法"></a><span id="8">左右固定宽度中间自适应的布局方法</span></h3><h3 id="自身浮动法"><a href="#自身浮动法" class="headerlink" title="自身浮动法"></a><span id="9">自身浮动法</span></h3>通过左右两栏浮动，中间部分自己顶上去并填满，再用BFC或者margin左右宽度去实现</li>
</ul>
<pre><code class="html">&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .div1 {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
    }
    .div3 {
        width: 200px;
        height: 200px;
        background-color: black;
        float: right;
    }
    .div2 {
        height: 300px;
        background-color: blue;
        overflow: hidden;
        /*或者通过设置左右的margin去调整*/
    }
&lt;/style&gt;
</code></pre>
<h3 id="通过设置负边距"><a href="#通过设置负边距" class="headerlink" title="通过设置负边距"></a><span id="10">通过设置负边距</span></h3><p>设置 <code>margin-left:100%</code> 能够使div1贴紧div4的左边缘，而 <code>margin-left:-200px;</code> 则会使div3贴紧右边缘，通过设置div2两侧的margin而处于合适位置。此时div1和div3仍在div4上方</p>
<pre><code class="html">&lt;div class=&quot;div4&quot;&gt;
    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .div4 {
        width: 100%;
        float: left;
    }
    .div2 {
        height: 300px;
        background-color: blue;
        margin: 0 200px;
    }
    .div1 {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
        margin-left: -100%;
    }
    .div3 {
        width: 200px;
        height: 200px;
        background-color: black;
        float: left;
        margin-left: -200px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a><span id="11">圣杯布局</span></h3><p>通过给最外层套的div设置padding，给固定尺寸的让出两侧的空间，再让内部的都浮动起来，然后固定尺寸的通过负边距调整。左侧的先通过 <code>margin-left:-100%;</code> 来调到左侧，再通过相对定位挪到之前 <code>padding</code> 腾出来的空间。而右侧则利用 <code>margin-right</code> 为自身宽度的方法，使自己宽度缩为0，从而挪上去。</p>
<p>圣杯布局优点：</p>
<blockquote>
<ul>
<li>两边带有固定宽度中间可以流动（fluid）；</li>
<li>允许中间一栏最先出现；</li>
<li>允许任意一栏放在最上面；</li>
<li>仅需一个额外的 div 标签</li>
<li>仅需非常简单的 CSS，带上最少的兼容性补丁</li>
</ul>
</blockquote>
<pre><code class="html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .container {
        padding: 0 300px 0 200px;
    }
    .container:after {
        content: &quot;&quot;;
        display: table;
        clear: both;
    }
    .main {
        width: 100%;
        height: 300px;
        background-color: blue;
        float: left;
    }
    .left {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
        margin-left: -100%;
        right: 200px;
        position: relative;
    }
    .right {
        width: 300px;
        height: 200px;
        background-color: black;
        float: left;
        margin-right: -300px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a><span id="12">双飞翼布局</span></h3><p>先让肢体摆好，然后插翅膀，再把关键部位摆放好。基本的一些思路跟圣杯布局很像</p>
<pre><code class="html">&lt;div class=&quot;middle&quot;&gt;
    &lt;div class=&quot;middle-2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .middle{
        width: 100%;
        height: 300px;
        float: left;
    }
    .left {
        width: 300px;
        height: 300px;
        background-color: green;
        float: left;
        margin-left: -100%;
        position: relative;
    }
    .right {
        width: 200px;
        height: 200px;
        background-color: blue;
        float: left;
        margin-left: -200px;
        position: relative;
    }
    .middle-2 {
        margin: 0 200px 0 300px;
        background-color: red;
    }
&lt;/style&gt;
</code></pre>
<h3 id="右栏固定宽度，左栏自适应的布局"><a href="#右栏固定宽度，左栏自适应的布局" class="headerlink" title="右栏固定宽度，左栏自适应的布局"></a><span id="1">右栏固定宽度，左栏自适应的布局</span></h3><p>在做下一个的时候，用自己想的一个方法去实现的话感觉还是有必要写一下这个类型</p>
<pre><code class="html">&lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .main:after {
        content: &quot;&quot;;
        display: table;
        clear: both;
    }
    .left {
        width: 100%;
        height: 200px;
        float: left;
        background-color: blue;
    }
    .right {
        float: left;
        width: 300px;
        height: 300px;
        background-color: red;
        margin-left: -300px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="中间宽度固定，左右自适应的布局"><a href="#中间宽度固定，左右自适应的布局" class="headerlink" title="中间宽度固定，左右自适应的布局"></a><span id="13">中间宽度固定，左右自适应的布局</span></h3><p>在搜索资料的时候偶然看见了这种布局要求，顺便也整理一下</p>
<pre><code class="html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .main {
        width: 300px;
        height: 200px;
        overflow: hidden;
        background-color: blue;
        float: left;
    }
    .left {
        /*width: 50%;*/
        height: 240px;
        background-color: red;

    }
    .right {
        /*width: 50%;*/
        height: 350px;
        background-color: black;

    }
&lt;/style&gt;
</code></pre>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.zhihu.com/question/21679928" target="_blank" rel="external">流布局与响应式网页设计有什么区别？</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2010/01/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%80%9D%E6%83%B3%E6%B5%85%E8%AE%AE-%E6%B7%98%E5%AE%9D%E6%96%B0%E7%89%88%E9%A6%96%E9%A1%B5%E4%B8%BA%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">网页布局思想浅议-淘宝新版首页为实例</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2011/09/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80/" target="_blank" rel="external">应运而生的web页面响应布局</a></li>
<li><a href="http://luopq.com/2015/11/08/CSS-float/" target="_blank" rel="external">详解CSS float属性</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">前端精选文摘：BFC 神奇背后的原理</a></li>
<li><a href="http://www.html-js.com/article/1866" target="_blank" rel="external">CSS之BFC详解</a></li>
<li><a href="http://www.w3cplus.com/blog/104.html" target="_blank" rel="external">CSS三栏布局——中间固定两边自适应宽度</a></li>
<li><a href="https://segmentfault.com/a/1190000004524159" target="_blank" rel="external">关于「圣杯布局」</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉好久没咋写过样式了，手有些生，顺便借整理的机会熟悉一下&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://regiondavid.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="整理归纳" scheme="http://regiondavid.github.io/blog/tags/%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>知识点记录</title>
    <link href="http://regiondavid.github.io/blog/2016/10/20/%E4%B8%80%E7%82%B9%E5%B0%8F%E4%B8%9C%E8%A5%BF/"/>
    <id>http://regiondavid.github.io/blog/2016/10/20/一点小东西/</id>
    <published>2016-10-20T08:30:00.000Z</published>
    <updated>2016-10-27T08:57:23.599Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己平时学习过程中忽视的或者遗忘的知识点<br><a id="more"></a></p>
<h4 id="return-a-amp-amp-b"><a href="#return-a-amp-amp-b" class="headerlink" title="return a &amp;&amp; b;"></a>return a &amp;&amp; b;</h4><p>if(a){<br>    return b;<br>} else return a;</p>
<h4 id="return-a-b"><a href="#return-a-b" class="headerlink" title="return a || b;"></a>return a || b;</h4><p>if(a){<br>    return a;<br>} else return b;</p>
<blockquote>
<p>As defined in the method signature, you will have to return a boolean. Therefore, after the return keyword, you will have to provide a boolean or an expression which is evaluated to boolean</p>
<p>In your case you have the expession (subTree(t1.left, t2) || subTree(t1.right, t2)); in which the two operands will be evaluated to boolean and you will apply an logical OR on them only if the first evaluates to false. If the first operand evaluates to true the second will not be evaluated and true will be retured.</p>
</blockquote>
<p>也就是说return是要返回一个布尔值或者能够决定这个表达式布尔值的关键因素</p>
<p>参考 <a href="http://stackoverflow.com/questions/21556993/java-in-return-statements" target="_blank" rel="external">回答一</a> <a href="http://stackoverflow.com/questions/4490274/returning-with" target="_blank" rel="external">回答二</a> <a href="http://stackoverflow.com/questions/5417969/why-dont-logical-operators-and-always-return-a-boolean-result" target="_blank" rel="external">回答三</a></p>
<h4 id="String-prototype-split-str"><a href="#String-prototype-split-str" class="headerlink" title="String.prototype.split(str)"></a>String.prototype.split(str)</h4><ul>
<li>字符串中如果有指定的str字符串，就把原字符串从这个地方截断，并依次存在新数组中再返回</li>
</ul>
<p>eg:</p>
<pre><code class="js">var str1 = &quot;ssxs:xsfas&quot;;str1.split(&quot;:&quot;);//[&quot;ssxs&quot;,&quot;xsfas&quot;]
</code></pre>
<ul>
<li>如果字符串中没有指定str字符串，就会把整个字符串存在一个新数组中再返回<br>eg:</li>
</ul>
<pre><code class="js">var str2 = &quot;ageafaefe&quot;;
str2.split(&quot;:&quot;);
//[&quot;ageafaefe&quot;]
</code></pre>
<ul>
<li>如果字符串中有不止一个指定的str字符串，那么会在每个符合str字符串的地方截断，依次拼成一个数组再返回<br>eg:<pre><code class="js">var str3 = &quot;qq:ff:gg&quot;;
str3.split(&quot;:&quot;);
//[&quot;qq&quot;,&quot;ff&quot;,&quot;gg&quot;]
</code></pre>
<h4 id="position-absolute之后，默认不是顶到左上角，而是保持在原来位置"><a href="#position-absolute之后，默认不是顶到左上角，而是保持在原来位置" class="headerlink" title="position:absolute之后，默认不是顶到左上角，而是保持在原来位置"></a><code>position:absolute</code>之后，默认不是顶到左上角，而是保持在原来位置</h4><h4 id="两个-div-都-display-inline-block-之后，中间有间隙"><a href="#两个-div-都-display-inline-block-之后，中间有间隙" class="headerlink" title="两个 div 都 display: inline-block 之后，中间有间隙"></a>两个 div 都 <code>display: inline-block</code> 之后，中间有间隙</h4>此处的空隙就是代码之间的换行符（有说空格符）的空隙</li>
</ul>
<h5 id="消除办法"><a href="#消除办法" class="headerlink" title="消除办法"></a>消除办法</h5><ul>
<li>可以把源代码放到一行去</li>
<li>把字符设置成0px的大小：<code>font-size:0;</code>  缺点：据说在IE7下有1px的空隙，顺便更正张鑫旭博文中的一点，目前chrome已经支持 <code>font-size:0</code> 了，可以放心使用；</li>
<li>使用<code>letter-spaceing: -4px;</code> 去设置字符间的间距。至于具体的设置多少还是要去看使用的字体，比如我测试的时候，设置了-10px才起作用。</li>
</ul>
<p>参考 <a href="http://www.zhangxinxu.com/wordpress/2010/11/%E6%8B%9C%E6%8B%9C%E4%BA%86%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80-%E5%9F%BA%E4%BA%8Edisplayinline-block%E7%9A%84%E5%88%97%E8%A1%A8%E5%B8%83%E5%B1%80/" target="_blank" rel="external">张鑫旭的这篇文章</a>的第五部分</p>
<h3 id="第一个div浮动之后，第二个div默认宽度是100-；"><a href="#第一个div浮动之后，第二个div默认宽度是100-；" class="headerlink" title="第一个div浮动之后，第二个div默认宽度是100%；"></a>第一个div浮动之后，第二个div默认宽度是100%；</h3><p>eg:</p>
<pre><code class="html">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    #div1{
        float:left;
    }
    #div2{
        height: 200px;
        background-color: red;
    }
&lt;/style&gt;
</code></pre>
<p>上述代码会出现这种效果<br><img src="http://p1.bpimg.com/1949/bee747d7df63c4da.png" alt="Markdown"><br>因为div的默认宽度都是自适应的100%，而且浮动会创建一个BFC，BFC对外界元素是没有影响的，同时会根据方向紧靠对应的边缘，这就是div1会贴在左边缘的原因，而div2则占据了剩下的所有空间，在二列布局中，我们除了让div2通过 <code>margin-left</code> 的方式去跟div1并列之外，也可以让div2也变成一个BFC，这样就可以并列在一起了，因为BFC不会与浮动盒子叠加。</p>
<p>另：块级元素默认宽度是100%；只设置高度即可。</p>
<h4 id="css-中-left、right、top、bottom-的使用"><a href="#css-中-left、right、top、bottom-的使用" class="headerlink" title="css 中 left、right、top、bottom 的使用"></a><code>css</code> 中 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 的使用</h4><h4 id="如何遍历一个对象"><a href="#如何遍历一个对象" class="headerlink" title="如何遍历一个对象"></a>如何遍历一个对象</h4><ul>
<li>Object.keys(obj)</li>
<li>for-in loop</li>
<li>map</li>
</ul>
<blockquote>
<p>the difference being that a for-in loop enumerates properties in the prototype chain as well</p>
</blockquote>
<p>参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">Object.keys</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录自己平时学习过程中忽视的或者遗忘的知识点&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://regiondavid.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="整理归纳" scheme="http://regiondavid.github.io/blog/tags/%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>代理模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/10/19/代理模式学习笔记/</id>
    <published>2016-10-19T12:30:00.000Z</published>
    <updated>2016-10-27T08:58:45.303Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式<br><a id="more"></a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
</blockquote>
<ul>
<li>小明追MM的例子<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39;+flower);
  }
};
xiaoming.sendFlower(A);
</code></pre>
添加代理B<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var B = {
  receiveFlower: function(flower){
      A.receiveFlower(flower);
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39;+flower);
  }
};
xiaoming.sendFlower(B);
</code></pre>
添加B监听A<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var B = {
  receiveFlower: function(flower){
      A.listenGoodMood(function(){
          A.receiveFlower(flower);
      })
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39; + flower);
  },
  listenGoodMood: function(fn){
      setTimeout(function(){
          fn();
      },10000);
  }
};
xiaoming.sendFlower(B);
</code></pre>
</li>
<li>保护代理和虚拟代理<ul>
<li>保护代理：<blockquote>
<p>代理B可以帮助A过滤掉一些请求。这些请求可以直接在代理B处理时被拒绝掉。</p>
</blockquote>
</li>
<li>虚拟代理：<blockquote>
<p>把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>eg:</p>
<pre><code class="js">var B = {
    receiveFlower: function(flower){
        A.listenGoodMood(function(){
            var flower = new Flower();
            A.receiveFlower(flower);
        })
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>策略模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/19/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://regiondavid.github.io/blog/2016/10/19/策略模式/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2016-10-20T01:21:42.210Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式学习笔记<br><a id="more"></a></p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote>
<p>定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。</p>
</blockquote>
<p>可以理解为把目标相同的算法封装到一个策略对象中，然后去给定参数去调用。</p>
<p>将不变的和变的隔离开</p>
<ul>
<li>一个传统的demo<pre><code class="js">  var performanceS = function(){};
  performanceS.prototype.calculate = function(salary){
      return salary*4;
  }
  var performanceA = function(){};
  performanceA.prototype.calculate = function(salary){
      return salary*2;
  }
  var performanceB = function(){};
  performanceB.prototype.calculate = function(salary){
      return salary*1;
  }
  var Bonus = function(){
      this.salary = null;
      this.strategy = null;
  }
  Bonus.prototype.setSalary = function(salary){
      this.salary = salary;
  }
  Bonus.prototype.setStrategy = function(strategy){
      this.strategy = strategy;
  }
  Bonus.prototype.getBonus = function(){
      return this.strategy.calculate(this.salary);
  }
</code></pre>
</li>
<li>一个js版的demo<blockquote>
<p>因为js中函数也是对象</p>
<pre><code class="js">  var strategies = {
      &quot;S&quot;: function(salary){
          return salary*4;
      },
      &quot;A&quot;: function(salary){
          return salary*2;
      },
      &quot;B&quot;: function(salary){
          return salary*1;
      }
  }
  var caculateBonus = function(level,salary){
      return strategies[level](salary);
  };
</code></pre>
</blockquote>
</li>
<li>策略模式在动画中的运用<pre><code class="js">//计算小球当前的位置
var tween = {
  //t:已消耗时间
  //b:初始位置
  //c:目标位置
  //d:持续时间
  linear: function(t,b,c,d){
      retrun c*t/d+b;
  },
  easeIn: function(t,b,c,d){
      return c*(t/=d)*t+b;
  },
  strongEaseIn: function(t,b,c,d){
      return c*(t/=d)*t*t*t*t+b;
  },
  strongEaseOut: function(t,b,c,d){
      return c*((t=t/d-1)*t*t*t*t+1)+b;
  }，
  sineaseIn:  function(t,b,c,d){
      return c*(t/=d)*t*t+b;
  },
  sineaseOut: function(t,b,c,d){
      return c*((t=t/d-1)*t*t+1)+b;
  }
};
</code></pre>
<pre><code class="html">&lt;body&gt;
  &lt;div style=&quot;position:absolute;background:blue&quot; id=&quot;test&quot;&gt;这是测试动画div&lt;/div&gt;
&lt;/body&gt;
</code></pre>
```js<br>var Amimate = function(dom){<br>  this.dom = dom;            //进行运动的dom节点<br>  this.startTime = 0;            //动画开始时间<br>  this.startPos = 0;            //动画开始时，dom节点的位置，即dom的初始位置<br>  this.endPos = 0;            //动画结束时，dom节点的位置，即dom的目标位置<br>  this.propertyName = null;    //dom节点需要被改变的css属性名<br>  this.easing = null;            //缓动算法<br>  this.duration = null;        //动画持续时间<br>}</li>
</ul>
<p>Anitmate.prototype.start = function(propertyName,endPos,duration,easing){<br>    this.startTime = +new Date;<br>    this.startPos = this.dom.getBoundingClientRect()[propertyName];<br>    this.endPos = endPos;<br>    this.duration = duration;<br>    this.easing = tween[easing];</p>
<pre><code>var self = this;
var timeId = setInterval(function(){
    if(self.step() === false){
        clearInterval(timeId);
    }
},19);
</code></pre><p>};</p>
<p>Animate.prototype.step = function(){<br>    var t = +new Date();<br>    if(t&gt;=this.startTime + this.duration){<br>        this.update(this.endPos);<br>        return false;<br>    }<br>    var pos = this.easing(t-this.startTime,this.startPos,this.endPos - this.startPos,this.duration);<br>    this.update(pos);<br>}</p>
<p>Aniamte.prototype.update = function(pos){<br>    this.dom.style[this.propertyName] = pos+’px’;<br>};</p>
<pre><code>&gt; 我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。

- 使用策略模式检验表单
```js
var strategies = {
    isNonEmpty: function(value,errorMsg){
        if(value === &#39;&#39;){
            return errorMsg;
        }
    },
    minLength: function(value,length,errorMsg){
        if(value.length &lt; length){
            return errorMsg;
        }
    },
    isMobile: function(value,errorMsg){
        if(!/(^1[3|5|8|9][0-9]{9}$)/).test(value){
            return errorMsg;
        }
    }
}

//创建一个validator类
function Validator(){
    this.cache = [];
}
Validator.prototype.add = function(dom,rules){
    var self = this;
    for(vsr i = 0,rule;rule = rules[i++];){
        (function(rule){
            var strategyAry = rule.strategy.split(&#39;:&#39;);
            var errorMsg = rule.errorMsg;
            self.cache.push(function(){
                var strategy = strategyAry.shift();
                strategyAry.unshift(dom.value);
                strategyAry.push(errorMsg);
                return strategied[strategy].apply(dom,strategyAry);
            });
        })(rule)
    }
}
Validator.prototype.start = function(){
    for(var i=0,validatorFunc;validatorFunc = this.cache[i++];){
        var msg = validatorFunc();
        if(msg){
            return msg;
        }
    }
}
</code></pre><ul>
<li>策略模式优缺点<ul>
<li>优点<blockquote>
<p>可以避免很多<code>if-else</code>语句；便于后期的维护和扩展；strategies可复用；</p>
</blockquote>
</li>
<li>缺点<blockquote>
<p>strategies会暴露所有的方法 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://regiondavid.github.io/blog/2016/10/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://regiondavid.github.io/blog/2016/10/14/单例模式/</id>
    <published>2016-10-14T07:30:00.000Z</published>
    <updated>2016-10-19T08:51:57.938Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式学习笔记<br><a id="more"></a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<blockquote>
<p>因为JavaScript本身就是无类的，既然我们只需要一个“唯一”的对象，为什么要先为它创建一个“类”呢？更加需要</p>
</blockquote>
<p>所以单例模式其实更加需要注意的是全局变量的污染。<br>常用在只需要绑定一次的代码或者只生成一个对象上，类似JQ的one</p>
<ul>
<li><p>简单demo</p>
<pre><code class="js">  var Singleton = function(name){
      this.name = name;
      this.instance = null;
  };
  Singleton.prototype.getName = function(){
      console.log(this.name);
  };
  Singleton.getInstance = function(name){
      if(!this.instance){
          this.instance = new Singleton();
      }
      return this.instance;
  };
  var a = Singleton.getInstance(&#39;sven1&#39;);
  var b = Singleton.getInstance(&#39;sven2&#39;);

  console.log(a===b);
</code></pre>
</li>
<li>透明的单例模式<pre><code class="js">  var CreateDiv = (function(){
      var instance;
      var CreateDiv = function( html){
          if(instance) {
              return instance;
          }
          this.html = html;
          this.init();
          return instance = this;
      };
      CreateDiv.prototype.init = function(){
          var div = document.createElement(&#39;div&#39;);
          div.innerHTML = this.html;
          document.body.appendChild(div);
      };
      return CreateDiv;
  })();
  //用闭包和IIFE封装instance
  var a = new CreateDiv( &#39;&lt;p&gt;222&lt;/p&gt;&#39;);
  var b = new CreateDiv( &#39;sven2&#39;);
  console.log(a===b);
</code></pre>
</li>
<li>用代理实现单例模式<br>把判断是否有instance提取出来，方便createDiv的复用<pre><code class="js">  var CreateDiv = function(html){
      this.html = html;
      this.init();
  };
  CreateDiv.prototype.init = function(){
      var div = document.createElement(&#39;div&#39;);
      div.innerHTML = this.html;
      document.body.appendChild(div);
  }
  var ProxySingletonCreateDiv = (function(){
      var instance;
      return function(html){
          if(!instance){
              instance = new CreateDiv(html);
          }
          return instance;
      }
  })();
  var a = new ProxySingletonCreateDiv(&#39;sven1&#39;);
  var b = new ProxySingletonCreateDiv(&#39;sven2&#39;);
  console.log(a===b);
</code></pre>
</li>
<li>惰性单例<blockquote>
<p>在需要时才创建对象实例</p>
<pre><code class="js">  Singleton.getInstance = (function(){
      var instance = null;
      return function(name){
          if(!instance){
              instance = new Singleton(name);
          }
          return instance;
      }
  })();
</code></pre>
<p>将上述代码中的单例判断逻辑抽离出来</p>
<pre><code class="js">  var getSingle = function(fn){
      var result;
      return function(){
          return result || (result = fn.apply(this,arguments));    
      }
  }
</code></pre>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/10/12/设计模式学习笔记/</id>
    <published>2016-10-12T01:30:00.000Z</published>
    <updated>2016-10-19T08:56:02.791Z</updated>
    
    <content type="html"><![CDATA[<p>跟着 《<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="external">JavaScript设计模式与开发实践</a>》 一书学习设计模式<br><a id="more"></a></p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="../../14/单例模式/">单例模式</a></li>
<li><a href="../../19/策略模式/">策略模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着 《&lt;a href=&quot;https://book.douban.com/subject/26382780/&quot;&gt;JavaScript设计模式与开发实践&lt;/a&gt;》 一书学习设计模式&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://regiondavid.github.io/blog/categories/code/"/>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="随笔" scheme="http://regiondavid.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="code" scheme="http://regiondavid.github.io/blog/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>盒模型的继续探索——margin属性</title>
    <link href="http://regiondavid.github.io/blog/2016/07/19/blog2/"/>
    <id>http://regiondavid.github.io/blog/2016/07/19/blog2/</id>
    <published>2016-07-19T13:41:44.000Z</published>
    <updated>2016-08-08T13:54:25.068Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们了解了盒模型的基本概念，并初步尝试了一下，结果最后留下了个问题还没解决。那么今天我们就把上次的问题解决掉，顺便研究一下盒模型中的一个重要部分——margin<br><a id="more"></a></p>
<p>####先看上次的问题：</p>
<pre><code class="html">    &lt;div id=&quot;div1&quot;&gt;
          &lt;div id=&quot;div2&quot;&gt;2333&lt;/div&gt;
    &lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #div1{
            width:500px;
            height: 300px;
            background-color: green;
        }
        #div2{
            margin-top:50px;
            padding-top: 50px;
            width:300px;
            height: 100px;
            background-color: blue;
        }
    &lt;/style&gt;
</code></pre>
<p>结果是这样的：<br><img src="http://i4.piimg.com/1949/f51c11a305253f94.png" alt="image1.png"><br>可以看到div2不仅没有和div1隔开50px的距离，反而div1和div2一起向下移动了50px，在上方空出了50px的空白，这是怎么回事？</p>
<p>首先让我们看看MDN上对margin属性的定义</p>
<blockquote>
<p>margin属性为给定元素设置所有四个（上下左右）方向的外边距属性。这是四个外边距属性设置的简写。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数。</p>
<p>形式语法:   [ <length> | <percentage> | auto ]{1,4}</percentage></length></p>
<p>margin: style                  /<em>单值语法   </em>/  举例： margin: 1em; </p>
<p>margin: vertical horizontal    /<em>二值语法   </em>/  举例： margin: 5% auto; </p>
<p>margin: top horizontal bottom  /<em>三值语法 </em>/  举例： margin: 1em auto 2em; </p>
<p>margin: top right bottom left  /<em>四值语法  </em>/  举例： margin: 2px 1em 0 auto; </p>
<p>margin: inherit</p>
</blockquote>
<p>注意：</p>
<ul>
<li>当同时为某个元素设置4个margin属性的时候，按照上右下左的顺序，为了便于记忆可以记住是顺时针顺序</li>
<li>当某个元素的margin-left和margin-right设置为auto时，一般为水平居中，这也是我们平时最常用的水平居中方法</li>
</ul>
<p>再来看一下我们之前的那个例子，其实问题很简单，就是由于margin计算的是兄弟级的盒模型，而div2就是那一级唯一的一个盒子，所以当div2向下移动了50px的时候，div1必须紧贴着div2，所以也跟着向下移动了50px。</p>
<p>如此说来，要想出现我们所需要的效果，只需要为div2添加浮动即可。比如：<code>float:left</code>。</p>
<pre><code class="css">    #div2{
            margin-top:50px;
            padding-top: 50px;
            width:300px;
            height: 100px;
            background-color: blue;
             float: left;
        }
</code></pre>
<p><img src="http://i1.piimg.com/1949/10abbd886ca3fedd.png" alt="image2"></p>
<h3 id="扩展：外边距塌陷"><a href="#扩展：外边距塌陷" class="headerlink" title="扩展：外边距塌陷"></a>扩展：外边距塌陷</h3><p>在MDN上有着明确的定义</p>
<blockquote>
<p>块元素的 top 与 bottom 外边距有时会合并（塌陷）为单个外边距（合并后最大的外边距），这样的现象称之为 外边距合并(塌陷)。</p>
</blockquote>
<p>下面三种基本情形会出现外边距塌陷：</p>
<ul>
<li>毗邻兄弟元素<blockquote>
<p>毗邻的兄弟元素的外边距会塌陷（当靠后的元素清除浮动时除外）</p>
</blockquote>
</li>
<li>父元素与第一个/最后一个子元素<blockquote>
<p>如果块元素的 margin-top 与它的第一个子元素的margin-top 之间没有 border、padding、inline content、 clearance 来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的margin-bottom 之间没有 border、padding、inline content、height、min-height、 max-height 分隔，那么外边距会合并(塌陷)。子元素多余的外边距会被父元素的外边距截断。</p>
</blockquote>
</li>
<li>空块元素<blockquote>
<p>如果块元素的 margin-top 与 margin-bottom 之间没有 border、padding、inline content、height、min-height 来分隔，那么它的上下外边距将会合并。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>即使外边距为0，这些规则仍旧生效。因此，无论父元素的外边距是否为0，第一个或者最后一个子元素的外边距会被父元素的外边距截断(根据上面的规则)，在负外边距的情况下，合并后的外边距为最大正外边距与最小负外边距之和。</p>
<p>浮动 及 绝对定位 元素外边距不会合并。</p>
</blockquote>
<p>关于外边距塌陷，有兴趣的同学可以自己尝试一下。</p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin" target="_blank" rel="external">margin属性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="external">外边距合并（塌陷）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次我们了解了盒模型的基本概念，并初步尝试了一下，结果最后留下了个问题还没解决。那么今天我们就把上次的问题解决掉，顺便研究一下盒模型中的一个重要部分——margin&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>盒模型的科普及一点小探索</title>
    <link href="http://regiondavid.github.io/blog/2016/07/13/blog1/"/>
    <id>http://regiondavid.github.io/blog/2016/07/13/blog1/</id>
    <published>2016-07-13T13:41:44.000Z</published>
    <updated>2016-07-30T14:09:42.054Z</updated>
    
    <content type="html"><![CDATA[<p>盒模型的科普及一点小探索<br><a id="more"></a></p>
<h3 id="什么是盒模型？"><a href="#什么是盒模型？" class="headerlink" title="什么是盒模型？"></a>什么是盒模型？</h3><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="external">MDN上的解释</a></p>
<blockquote>
<p>文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。在CSS中，这些矩形盒子用 标准盒模型 来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界margin edge, 边框边界border edge, 内边距边界padding edge 与 内容边界content edge。 </p>
</blockquote>
<p>可以看出盒模型就像它的名字那样，指的就是一个矩形盒子，但是这个盒子有外边距、内边距、边框和内容区域。如下图所示：<br><img src="http://www.w3school.com.cn/i/ct_boxmodel.gif" alt="盒模型"></p>
<p>从图可以看出，我们平时所定义的 width 和 height 都是对应的内容区域，但是当我们在布局的时候，则是依照盒模型的尺寸去进行布局。所以在最后计算的时候：<code>盒模型的宽度 = margin 的宽度 + padding 的宽度 + border 的宽度 + 内容区域的宽度</code>。<br>似乎将 padding 和 border 也计算在宽度里不大符合我们常人的思维，IE 也是这么想的。所以在 IE 下和其他浏览器下计算的尺寸是不一样的。对此，css3 提出了 box-sizing 这个属性。box-sizing 有两个可选值，一个是默认的 content-box，另一个就是 border-box。当把 box-sizing 设置为 content-box 的时候，计算尺寸就把所有的都加起来；当设置为 border-box 时，就类似IE的计算方法，将 padding 和 border 算在 width 和 height 里。掌握这些基础对页面的布局有着非常好的帮助。</p>
<h3 id="一点有趣的探索"><a href="#一点有趣的探索" class="headerlink" title="一点有趣的探索"></a>一点有趣的探索</h3><pre><code class="html">    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #div1{
            width:500px;
             height: 300px;
            background-color: green;
        }
        #div2{
            width:300px;
             height: 100px;
            background-color: blue;
        }
    &lt;/style&gt;
</code></pre>
<p>这是最初的样子<img src="http://i4.piimg.com/4851/50f5caa366cd86c5.png" alt="test1"><br>当我把css稍作修改</p>
<pre><code class="css">    #div2{
      padding-top:50px;
      width:300px;
      height: 100px;
      background-color: blue;
    }
</code></pre>
<p>结果变成了这个样子。。。<br><img src="http://i2.piimg.com/4851/aeeee223f73c2a76.png" alt="test2"><br><img src="http://www.18183.com/uploads/150805/41-150P51Q24Q15.jpg" alt="什么鬼">，div2咋还变长了？<br>于是我开始了探索(<del>瞎折腾</del>)<br>首先在div中添加几个字，看看content区域有没有变，内容区域果然正常<img src="http://i2.piimg.com/4851/86e535e23ba2bb32.png" alt="test3"><br>可以很明显对比看到内容区域向下移动了50px的距离，但是为什么内容的上方仍然是蓝色呢？<br>还记得我们开头的话吗？</p>
<blockquote>
<p>文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。</p>
</blockquote>
<p>而这里渲染的背景颜色就是基于盒模型去渲染的，它会把padding部分和content部分都去渲染上背景色。<br>那么问题又来了，如果再设置margin属性，背景色会不会也渲染上呢？</p>
<pre><code class="css">    #div2{
      margin-top:50px;
      padding-top:50px;
      width:300px;
      height: 100px;
      background-color: blue;
    }
</code></pre>
<p>渲染出来的结果竟然是<img src="http://i2.piimg.com/4851/e5299204e93b1362.png" alt="test4"><br>结果div2的背景色不仅没有变化，div1上边竟然还多出一块空白的？！<br><img src="http://easyread.ph.126.net/4r1X30AHvtnDORiKVCvsHw==/7916690428175172728.jpg" alt="WTF"></p>
<p>这他喵的是咋回事？</p>
<p>预知后事如何，且听下回分解</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒模型的科普及一点小探索&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
