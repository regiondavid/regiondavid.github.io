<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Regiondavid&#39;s Blog</title>
  <subtitle>something about code , life and thought</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://regiondavid.github.io/blog/"/>
  <updated>2016-12-04T13:49:25.560Z</updated>
  <id>http://regiondavid.github.io/blog/</id>
  
  <author>
    <name>Region David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>来上海一周记</title>
    <link href="http://regiondavid.github.io/blog/2016/12/04/%E6%9D%A5%E4%B8%8A%E6%B5%B7%E4%B8%80%E5%91%A8%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/12/04/来上海一周记/</id>
    <published>2016-12-03T16:00:00.000Z</published>
    <updated>2016-12-04T13:49:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间来上海已经一周了，就写一写吧，也当做对上一周的一些反思，尽量保持每周一篇<br><a id="more"></a></p>
<h4 id="终于还是出来了。"><a href="#终于还是出来了。" class="headerlink" title="终于还是出来了。"></a>终于还是出来了。</h4><p>在经历了接近一个月的找实习与准备中终于还是出来了。记得当时还是因为看见了魏巅峰发的那个百度地图车的实习广告，然后又被王老师一阵忽悠着一起写简历投简历，就开始了几经风波的找实习过程。</p>
<p>现在再去看那段时间，就感觉有两句话总结的太™的对了</p>
<blockquote>
<p>生活最不缺的就是幽默，生活最有意思的就是阴差阳错</p>
</blockquote>
<p>还有那句中国的老话：</p>
<blockquote>
<p>有心栽花花不开，无心插柳柳成荫</p>
</blockquote>
<p>阴差阳错，机缘巧合下我来到了魔都。</p>
<p>从确定要走到最后的出发其实只有一周的时间，感觉走得挺匆忙的，走之前那一周也是啥也看不进去，有点激动又有点慌张，只是把磨锤子课的实验报告给写了，剩下及以后的就交给队友们了2333。</p>
<p>一路恍惚中就来到了上海，住进了早在v2ex上找好的房子里，一顿买买买（顺便吐槽一下上海的物价）之后，周一就去报道了。</p>
<h4 id="初进公司"><a href="#初进公司" class="headerlink" title="初进公司"></a>初进公司</h4><p>感觉确实跟一切不一样了，以前在工作室待一天可能比较随意一些，想干什么就干些什么，也能随便跟老师们一起吹吹逼。环境跟想象中又有些不同，但也挺满意的。有零食有饮料有加班餐，而且印象最深的就是这的氛围，讨论交流特别多，经常能看到有人抱着电脑到处去问，而且因为团队人数不是特别多，所以管理比较扁平化，leaders也经常跟工程师们在一起交流。整体的包括工作管理等个人感觉也挺专业的。</p>
<h4 id="自我的反思"><a href="#自我的反思" class="headerlink" title="自我的反思"></a>自我的反思</h4><ul>
<li>懒散<br>感觉又进入了传说中的技术舒适区了，缺乏紧迫感，其实从正式拿到offer之后就开始了，一直没调整过来。可能从下周开始任务多起来会好转吧。感觉也要做一下个人的规划了，要不周末的大好时间又浪费掉了。</li>
<li>社交懒惰放不开<br>在这一周的交流实在不多，就连跟mentor都没有太多的交流，一方面确实是人认不全，又担心打扰别人，另一方面就是自己太懒，不肯主动去问去学。适应新环境慢确实也是自己一直以来的问题，这个只能靠时间去解决了，自己也去慢慢学习别人的交流方式。</li>
</ul>
<p>愿下周会变得更好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间来上海已经一周了，就写一写吧，也当做对上一周的一些反思，尽量保持每周一篇&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://regiondavid.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="上海" scheme="http://regiondavid.github.io/blog/tags/%E4%B8%8A%E6%B5%B7/"/>
    
      <category term="周记" scheme="http://regiondavid.github.io/blog/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://regiondavid.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>发布-订阅模式 学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/11/22/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://regiondavid.github.io/blog/2016/11/22/发布-订阅模式/</id>
    <published>2016-11-21T16:00:00.000Z</published>
    <updated>2016-12-04T03:41:18.075Z</updated>
    
    <content type="html"><![CDATA[<p>发布-订阅模式（观察者模式）学习笔记<br><a id="more"></a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<blockquote>
<p>在 <code>js</code> 中，常用事件模型来代替传统的 <code>发布-订阅模式</code></p>
</blockquote>
<h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a><code>DOM</code> 事件</h3><p>在原生 <code>js</code> 中，我们其实已经接触过了 <code>发布-订阅模式</code> – <code>addEventListener</code></p>
<p>eg: <code>document.body.addEventListener(&#39;click&#39;,function(){console.log(233);},false)</code></p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h5 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h5><ul>
<li>制定发布者</li>
<li>为发布者添加缓存队列，用于存放回调函数</li>
<li>当要发布消息的时候，就会遍历整个缓存列表，依次触发对应的回调函数</li>
</ul>
<h5 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h5><pre><code class="js">var salesOffices = {};
salesOffices.clientList = [];
salesOffices.listen = function(fn){
    this.clientList.push(fn);
};
salesOffices.trigger = function(){
    for(var i = 0, fn; fn = this.clientList[i++];){
        fn.apply(this, arguments);
    }
};
</code></pre>
<p>进行测试</p>
<pre><code class="js">salesOffices.listen(function(price, squareMeter){
    console.log(&#39;userA&#39;);
    console.log(&#39;价格=&#39;+price);
    console.log(&#39;面积=&#39;+squareMeter);
});
salesOffices.listen(function(price, squareMeter){
    console.log(&#39;userB&#39;);
    console.log(&#39;价格=&#39;+price);
    console.log(&#39;面积=&#39;+squareMeter);
});

salesOffices.trigger(200000,88);
//userA
//价格=200000
//面积=88
//userB
//价格=200000
//面积=88
//undefined
</code></pre>
<h5 id="稍作改进"><a href="#稍作改进" class="headerlink" title="稍作改进"></a>稍作改进</h5><p>在原基础上添加一些限制条件，使得接收者只获取自己想要的信息。</p>
<pre><code class="js">var salesOffices = {};
salesOffices.clientList = {};
salesOffices.listen = function(key, fn){
    if(!this.clientList[key]){
        this.clientList[key] = [];
    }
    this.clientList[key].push(fn);
};
salesOffices.trigger = function(){
    var key = Array.prototype.shift.call(arguments),
        fns = this.clientList[key];
    if(!fns || fns.length === 0){
        return false;
    }
    for(var i = 0, fn; fn = fns[i++];){
        fn.apply(this, arguments);
    }
};
</code></pre>
<p>进行测试</p>
<pre><code class="js">salesOffices.listen(&#39;squareMeter88&#39;, function(price){
    console.log(&#39;价格=&#39; + price);
    console.log(&#39;squareMeter88&#39;);
});
salesOffices.listen(&#39;squareMeter110&#39;, function(price))
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布-订阅模式（观察者模式）学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="发布-订阅模式" scheme="http://regiondavid.github.io/blog/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webpack对css打包的处理</title>
    <link href="http://regiondavid.github.io/blog/2016/11/14/webpack%E5%AF%B9css%E6%89%93%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://regiondavid.github.io/blog/2016/11/14/webpack对css打包的处理/</id>
    <published>2016-11-13T16:00:00.000Z</published>
    <updated>2016-11-14T14:06:37.873Z</updated>
    
    <content type="html"><![CDATA[<p>最近被问到了这个问题，当时就懵逼了，特在此做一下笔记。<br><a id="more"></a><br>首先我们都知道webpack作为前端自动化的一种构建工具，其打包能力是非常强的。不仅支持 <code>AMD</code>/<code>CMD</code>，而且还可以把 <code>css</code>（<code>scss</code>/<code>less</code>）、图片等非 <code>js</code>资源打包到一起，功能不可谓不强大。</p>
<h4 id="首先肯定是如何把-css（scss-less）打包到-js-中去"><a href="#首先肯定是如何把-css（scss-less）打包到-js-中去" class="headerlink" title="首先肯定是如何把 css（scss/less）打包到 js 中去"></a>首先肯定是如何把 <code>css</code>（<code>scss</code>/<code>less</code>）打包到 <code>js</code> 中去</h4><p>这个用过 <code>webpack</code> 的应该都有所了解。在 <code>webpack.config.js</code> 中的 <code>loaders</code> 里去添加</p>
<pre><code class="js">{
    test: /\.css$/,
    loaders: [&#39;style&#39;,&#39;css&#39;]
}
</code></pre>
<p>这样我们的 <code>js</code> 就会把这个 <code>css</code> 打包进去了。</p>
<h4 id="打包后的-css-是如何存在于-js-中啊"><a href="#打包后的-css-是如何存在于-js-中啊" class="headerlink" title="打包后的 css 是如何存在于 js 中啊"></a>打包后的 <code>css</code> 是如何存在于 <code>js</code> 中啊</h4><p>为此我特意找到原来的代码，扒了一下后，找到了这个</p>
<p><img src="http://p1.bpimg.com/1949/9f942ddf0851d46c.png" alt="Markdown"></p>
<p>可以看到我们的 <code>css</code> 代码以字符串的形式被存储了起来，并且有对应的 <code>module.id</code>，并最后输出出去</p>
<h4 id="那这段代码又是如何起作用的呢"><a href="#那这段代码又是如何起作用的呢" class="headerlink" title="那这段代码又是如何起作用的呢"></a>那这段代码又是如何起作用的呢</h4><p>这就回到了我们最开始的问题。当时我的想法是通过检测对应的 <code>id/class</code>，添加到对应元素的属性里。现在想来这种想法想的过于理想了，首先性能就是个问题，而且这样就体现不出来模块化的思想了。</p>
<p>要解决这个问题的话，还是得看 <code>webpack</code> 对处理 <code>css</code> 用到的两个 <code>loader</code>。我们一个一个来看。</p>
<p>首先是 <code>css-loader</code>。这是我在 <a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="external">https://www.npmjs.com/package/css-loader</a> 中找到的用处</p>
<blockquote>
<h5 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h5><p>var css = require(“css!./file.css”);</p>
<p>// =&gt; returns css code from file.css, resolves imports and url(…)</p>
<p>@import and url(…) are interpreted like require() and will be resolved by the css-loader. Good loaders for requiring your assets are the file-loader and the url-loader which you should specify in your config (see below).</p>
<p>To be compatible with existing css files (if not in CSS Module mode):</p>
<p>url(image.png) =&gt; require(“./image.png”)</p>
<p>url(~module/image.png) =&gt; require(“module/image.png”)</p>
</blockquote>
<p>大体意思就是说将 <code>css</code>代码从引入的 <code>css</code> 文件中引出来，同时还会解析引入 <code>css</code> 中会遇到的一些 <code>url</code> 和 <code>import</code> ，把它们解析成 <code>require(...)</code> 的形式。</p>
<p>然后是 <code>style-loader</code>，这是 <a href="https://github.com/webpack/style-loader" target="_blank" rel="external">https://github.com/webpack/style-loader</a> 上给出的作用。</p>
<blockquote>
<p>Adds CSS to the DOM by injecting a ‘style’ tag</p>
</blockquote>
<p>十分的简介明了，就是把解析出来的 <code>css</code> 代码通过在页面中插入一个 <code>style</code> 标签来处理。这也是我们为什么在 <code>loaders</code> 里先写 <code>style</code> 后写 <code>css</code> 的原因，这里要注意 <code>webpack</code> 加载这些 <code>loaders</code> 的时候，是按照从右往左的顺序去加载的。</p>
<p>至此，这个问题也是终于有了答案，<code>webpack</code> 先通过 <code>css-loader</code> 去取出 <code>css</code>代码，然后通过 <code>style-loader</code> 去把这些代码通过封装到一个 <code>style</code> 标签里然后添加到对应页面上。而把 <code>css</code> 打包到 <code>js</code> 里面的一个很重要的好处就是减少请求的数量，毕竟一个请求一寸金啊（滑稽</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被问到了这个问题，当时就懵逼了，特在此做一下笔记。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="webpack" scheme="http://regiondavid.github.io/blog/tags/webpack/"/>
    
      <category term="模块化" scheme="http://regiondavid.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>作用域及闭包学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/11/09/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/11/09/作用域及闭包学习笔记/</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2016-11-10T09:22:33.378Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试，在作用域和闭包这个地方出现了挺多问题，正好借此机会好好学习一下。<br><a id="more"></a></p>
<h4 id="编译器的作用之一——解析抽象语法树"><a href="#编译器的作用之一——解析抽象语法树" class="headerlink" title="编译器的作用之一——解析抽象语法树"></a>编译器的作用之一——解析抽象语法树</h4><p>根节点为VariableDeclaration，第一个子节点为Identifire，用来记录变量的名称；第二个子节点为AssignmentExpression，这个子节点会生成一个子节点，叫NumericLiteral，来存储对应变量的值。</p>
<h4 id="编译器对变量声明的处理"><a href="#编译器对变量声明的处理" class="headerlink" title="编译器对变量声明的处理"></a>编译器对变量声明的处理</h4><p>先在作用域内查询是否有同名的变量：如果存在，则忽略声明，继续执行；如果不存在，则分配内存去生成一个新变量</p>
<h4 id="对变量赋值的处理"><a href="#对变量赋值的处理" class="headerlink" title="对变量赋值的处理"></a>对变量赋值的处理</h4><p>先在作用域内查询是否有这个变量，如果有，则进行赋值操作，如果没有，则继续向上层去寻找，直到找到位置，如果一直到全局作用域都没有找到的话，则会报错。</p>
<h4 id="搜索变量"><a href="#搜索变量" class="headerlink" title="搜索变量"></a>搜索变量</h4><p>两种查询的方式，一种是LHS，目的是找到包含对应目标的容器，常用在赋值操作的左侧，如<code>a=2</code>；而另一种是RHS，目的是找到对应目标的确切的值，常用语引用该变量的时候，如<code>console.log(a)</code>。</p>
<blockquote>
<p>容易忽略的一个细节：</p>
<pre><code class="js">function foo(a){
    console.log(a);
}
foo(2);
</code></pre>
<p>在把2作为一个参数传给函数时，会需要进行一次LHS，从而给a赋值为2。这个函数内部的执行，会对a进行一次RHS操作，然后对console这个对象进行RHS，查询是否有log这个方法。</p>
</blockquote>
<p>如果之前没有定义过某个变量，对其赋值，会使那个变量成为一个全局变量。</p>
<p>因为在赋值的时候，对赋值左侧进行的是LHS，在非严格模式下，如果都没有找到这个变量，全局作用域会生成一个。</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>作用域分为两类，一类是词法作用域，js也是采用的这种；而另一种则是动态作用域，如Bash脚本或Perl。</p>
<p>词法作用域就是根据词法化后定义在词法阶段的作用域。</p>
<pre><code class="js">function foo(a){
    var b = a*2;
    function bar(c){
        console.log(a,b,c);
    }
    bar(b*3);
}
foo(2)
</code></pre>
<p>这个例子中创建了三个作用域：第一个为全局作用域，标识符为foo，第二个foo创建的作用域，标识符为a,b,bar；第三个是bar创建的作用域，标识符为c。函数的作用域包含该函数的参数。</p>
<blockquote>
<p>没有任何函数可以部分地同时出现在两个父级函数中。</p>
<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域只由函数被声明时所处的位置决定</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试，在作用域和闭包这个地方出现了挺多问题，正好借此机会好好学习一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="js基础" scheme="http://regiondavid.github.io/blog/tags/js%E5%9F%BA%E7%A1%80/"/>
    
      <category term="作用域" scheme="http://regiondavid.github.io/blog/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="http://regiondavid.github.io/blog/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="你不知道的JS" scheme="http://regiondavid.github.io/blog/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/"/>
    
  </entry>
  
  <entry>
    <title>JS再学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/11/07/js-basic-note/"/>
    <id>http://regiondavid.github.io/blog/2016/11/07/js-basic-note/</id>
    <published>2016-11-06T16:00:00.000Z</published>
    <updated>2016-11-14T14:07:16.148Z</updated>
    
    <content type="html"><![CDATA[<p><code>js</code> 复习笔记<br><a id="more"></a></p>
<h2 id="JS再学习笔记"><a href="#JS再学习笔记" class="headerlink" title="JS再学习笔记"></a>JS再学习笔记</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>先摆结果</p>
<h4 id="基本数据类型（简单数据类型）-–-5种"><a href="#基本数据类型（简单数据类型）-–-5种" class="headerlink" title="基本数据类型（简单数据类型） – 5种"></a>基本数据类型（简单数据类型） – 5种</h4><ul>
<li>Null</li>
<li>undefined</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
<h4 id="复杂数据类型-–-1种"><a href="#复杂数据类型-–-1种" class="headerlink" title="复杂数据类型 – 1种"></a>复杂数据类型 – 1种</h4><ul>
<li>Object</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Function</li>
<li>基本包装类型<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
</li>
<li>单体内置对象<ul>
<li>Global</li>
<li>Math<br>产品线</li>
</ul>
</li>
</ul>
<p>再提问题</p>
<blockquote>
<p>基本数据类型、复杂数据类型、引用数据类型、包装数据类型这些是怎样区分的</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;js&lt;/code&gt; 复习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="js" scheme="http://regiondavid.github.io/blog/tags/js/"/>
    
      <category term="js基础" scheme="http://regiondavid.github.io/blog/tags/js%E5%9F%BA%E7%A1%80/"/>
    
      <category term="js高级程序设计" scheme="http://regiondavid.github.io/blog/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Atom配置记录</title>
    <link href="http://regiondavid.github.io/blog/2016/10/30/ATOM%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://regiondavid.github.io/blog/2016/10/30/ATOM配置记录/</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2016-10-30T07:43:21.657Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学 <code>React</code>，发现 <code>sublime</code> 内对 <code>react</code> 的代码高亮实在是看着别扭，并且对 <code>react</code> 的语法支持的不是特别好，再加上没时间去专门折腾一下写个插件（<del>主要是懒</del>），所以就换到了 <code>Atom</code> 这来了。<br><a id="more"></a></p>
<h3 id="Atom下载插件慢或无反应的解决办法"><a href="#Atom下载插件慢或无反应的解决办法" class="headerlink" title="Atom下载插件慢或无反应的解决办法"></a>Atom下载插件慢或无反应的解决办法</h3><p>比较直接的办法就是直接用 <code>npm/apm</code> 去安装</p>
<ul>
<li>首先在 <code>setting</code> 里的 <code>install</code> 里去查找你所要下载的插件的名字，有些直接在 <code>README.md</code> 里直接说明怎样用命令行去下载；比如：<code>emmet</code></li>
<li>如果 <code>README.md</code> 里没有明说的话，你需要访问它的github，这个一般都会写出来的。然后把这个项目 <code>clone</code> 到你本机用户名下的 <code>.atom</code> 下的 <code>.packages</code> 下，然后进入这个文件夹，输入 <code>npm install</code>（如果使用 <code>apm</code>的话就是 <code>apm install</code>），至于怎样将 <code>npm</code> 的源更换成淘宝<code>apm</code> 的源就不在这说了，网上一搜一大堆。</li>
<li>当显示 <code>Installing modules done</code> 时，就说明已经安装成功了<h3 id="个人常用的Atom插件记录"><a href="#个人常用的Atom插件记录" class="headerlink" title="个人常用的Atom插件记录"></a>个人常用的Atom插件记录</h3></li>
<li>color-picker：快速调出调色盘选取颜色</li>
<li>WakaTime：记录平时的工作时间及工作状态</li>
<li>emmet：不解释，谁用谁知道</li>
<li>未完待续，发现好的再补充</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学 &lt;code&gt;React&lt;/code&gt;，发现 &lt;code&gt;sublime&lt;/code&gt; 内对 &lt;code&gt;react&lt;/code&gt; 的代码高亮实在是看着别扭，并且对 &lt;code&gt;react&lt;/code&gt; 的语法支持的不是特别好，再加上没时间去专门折腾一下写个插件（&lt;del&gt;主要是懒&lt;/del&gt;），所以就换到了 &lt;code&gt;Atom&lt;/code&gt; 这来了。&lt;br&gt;
    
    </summary>
    
    
      <category term="atom" scheme="http://regiondavid.github.io/blog/tags/atom/"/>
    
      <category term="记录" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>多种布局的回顾</title>
    <link href="http://regiondavid.github.io/blog/2016/10/22/%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://regiondavid.github.io/blog/2016/10/22/多种布局的探索/</id>
    <published>2016-10-22T01:20:00.000Z</published>
    <updated>2016-10-27T08:57:22.728Z</updated>
    
    <content type="html"><![CDATA[<p>感觉好久没咋写过样式了，手有些生，顺便借整理的机会熟悉一下<br><a id="more"></a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>按布局的尺寸及样式分<ul>
<li><a href="#1">固定布局</a></li>
<li><a href="#2">流体布局</a></li>
<li><a href="#3">响应式布局</a></li>
</ul>
</li>
<li>按布局的层次分<ul>
<li>三栏式布局<ul>
<li><a href="#4">最常规的三段式布局</a></li>
</ul>
</li>
<li>两栏式布局<ul>
<li><a href="#5">左右固定宽度的两栏式布局</a></li>
<li><a href="#6">左栏固定宽度，右栏自适应的布局</a></li>
<li><a href="#7">横向固定宽度的三段式布局</a></li>
<li><a href="#8">左右固定宽度中间自适应的布局方法</a><ul>
<li><a href="#9">自身浮动法</a></li>
<li><a href="#10">通过设置负边距</a></li>
<li><a href="#11">圣杯布局</a></li>
<li><a href="#12">双飞翼布局</a></li>
</ul>
</li>
<li><a href="#13">右栏固定宽度，左栏自适应的布局</a></li>
<li><a href="#14">中间宽度固定，左右自适应的布局</a></li>
</ul>
</li>
</ul>
</li>
<li>几种比较新的布局<ul>
<li><a href="#14">flex布局</a></li>
<li><a href="#15">grid布局</a></li>
</ul>
</li>
<li>未完待续（等以后出新的再补充）</li>
</ul>
<h3 id="固定布局"><a href="#固定布局" class="headerlink" title="固定布局"></a><span id="1">固定布局</span></h3><p>顾名思义，就是页面的宽度都写死，比如 <code>1024px</code> 等。比较典型的例子就是<a href="https://www.douban.com" target="_blank" rel="external">豆瓣网</a>。这样写的好处就是能够保证在不同的设备上显示的都是一样的，并且一些需要精密的效果时可以比较完好的实现。但是也是有不足的。比如当把宽度设为 <code>1920px</code> 时，如果在低分辨率的设备上访问时，就会出现滚动条，影响页面效果。</p>
<p>另一个缺点就是如果在低分辨率下写的比较满的页面，可能在高分辨率下就会出现大面积空白，比较浪费屏幕资源。</p>
<h3 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a><span id="2">流体布局</span></h3><p>为了解决固定布局的弊端，我们很自然的会想到用百分比去设置一些宽高，用 <code>em</code> 或者 <code>rem</code> 去设置字体大小，这就是我们所说的流体布局，也叫自适应布局。流体布局很好的解决了不同分辨率下甚至移动端的体验。</p>
<p>当然缺点也是存在的</p>
<blockquote>
<p>但缺点明显：宽度使用百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。</p>
<p>—— <a href="https://www.zhihu.com/question/21679928" target="_blank" rel="external">流布局与响应式网页设计有什么区别？郑杭的回答</a></p>
</blockquote>
<p>之前也有过类似的感觉，如果用百分比感觉在某个尺寸范围里变化会特别快，然后合在一起的样式就会非常诡异。特别是会出现本来一个宽大于高的块然后在移动端会变成高大于宽的一个块，整体的设计结构就变样了。见下图<br><img src="http://p1.bpimg.com/1949/87a379c1a9562bae.png" alt="Markdown"></p>
<p><img src="http://p1.bqimg.com/1949/c9446690188ecc06.png" alt="Markdown"></p>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a><span id="3">响应式布局</span></h3><p>响应式布局其实就是流式布局+媒体查询，在一定的尺寸内页面内容会按照百分比去缩放，当到达媒体查询设定的值后，会改动一部分内容的样式，以便在移动端获得更好的体验。常见的做法是把导航栏收到一个按钮里，点击之后会以下拉列表的形式展出，或者把与导航栏在一行的搜索框在缩小到一定尺寸后取消掉或者换到下一行，以张鑫旭大神的博客为例，见下图<br><img src="http://p1.bqimg.com/4851/09d534bfab5fbe3c.png" alt="响应式1"><br><img src="http://p1.bqimg.com/1949/bb1f0056eb825687.png" alt="Markdown"></p>
<p>至于在三种布局方式中如何取舍，还是看项目的需求，比如有些部分可以做成固定布局与自适应布局相结合的方式，可能更便于后期的维护。这个还是要靠自己经验的积累。</p>
<h3 id="最常规的三段式布局"><a href="#最常规的三段式布局" class="headerlink" title="最常规的三段式布局"></a><span id="4">最常规的三段式布局</span></h3><p>三段式布局是我们平时最常见到的布局方式。如下图<br><img src="http://i1.piimg.com/1949/8d2c19cf9b7c83eb.png" alt="实例一"><br>头部、身体和尾部很生动的显示出三部分的排列方式，即从上到下依次排列，实现起来也非常简单，写出三个DIV自己就排好了。此处也就不用代码去展示了。</p>
<h3 id="左右固定宽度的两栏式布局"><a href="#左右固定宽度的两栏式布局" class="headerlink" title="左右固定宽度的两栏式布局"></a><span id="5">左右固定宽度的两栏式布局</span></h3><p>这种布局也非常常见，实现方式也有很多，我们一一来尝试。</p>
<ul>
<li>规定好左右的宽度后，利用float浮动来实现</li>
</ul>
<pre><code class="html">    &lt;div class=&quot;box3&quot;&gt;
        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .box3{
            width: 100px;
            height: 300px;
            background-color: #A9A8A8;
        }
        .box1{
            width: 50px;
            height: 200px;
            float: left;
            background-color: #7068EB;
        }
        .box2{
            width: 50px;
            height: 200px;
            float: left;
            background-color: #FF3434;
        }
    &lt;/style&gt;
</code></pre>
<ul>
<li>一个向左浮，一个向右浮<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
      }
      .box1{
          width: 50px;
          height: 200px;
          float: left;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          float: right;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>一个不动，另一个通过绝对定位去移动<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
          position: relative;
      }
      .box1{
          width: 50px;
          height: 200px;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          position: absolute;
          top: 0px;
          left: 50px;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>改成行内元素，然后自然并排到一起<pre><code class="html">  &lt;div class=&quot;box3&quot;&gt;
          &lt;!-- 此处的div2和div3一定要记得把中间的换行符去掉，否则会产生空隙 --&gt;
          &lt;!-- 当然还有其他办法，就不在这说了，可以去看整理的《一点小东西》那篇里有整理 --&gt;
          &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      .box3{
          width: 100px;
          height: 300px;
          background-color: #A9A8A8;
      }
      .box1{
          width: 50px;
          height: 200px;
          display: inline-block;
          background-color: #7068EB;
      }
      .box2{
          width: 50px;
          height: 200px;
          display: inline-block;
          background-color: #FF3434;
      }
  &lt;/style&gt;
</code></pre>
</li>
<li>采用 <code>display:table-cell</code><h3 id="左或右固定宽度，另一侧自适应的布局"><a href="#左或右固定宽度，另一侧自适应的布局" class="headerlink" title="左或右固定宽度，另一侧自适应的布局"></a><span id="6">左或右固定宽度，另一侧自适应的布局</span></h3>此处方便起见，仅以左栏固定，右栏自适应为例</li>
<li>让固定高度的浮动，另一个通过 <code>margin</code> 让出距离或者通过BFC去实现（BFC的总结见<a href="">整理的这篇文章</a>）<br>因为不设高度的话，浮动起来会消失掉，也就无意义了<pre><code class="html">  &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="css">  &lt;style type=&quot;text/css&quot;&gt;
      #div1{
          width: 50px;
          height: 200px;
          float: left;
          background-color: #7068EB;
      }
      #div2{
          height: 230px;
          background-color: #FF3434;
          /*margin-left: 50px;*/
          overflow: hidden;
      }
  &lt;/style&gt;
</code></pre>
<h3 id="横向固定宽度的三段式布局"><a href="#横向固定宽度的三段式布局" class="headerlink" title="横向固定宽度的三段式布局"></a><span id="7">横向固定宽度的三段式布局</span></h3>这个不展开说了，方法挺多的<h3 id="左右固定宽度中间自适应的布局方法"><a href="#左右固定宽度中间自适应的布局方法" class="headerlink" title="左右固定宽度中间自适应的布局方法"></a><span id="8">左右固定宽度中间自适应的布局方法</span></h3><h3 id="自身浮动法"><a href="#自身浮动法" class="headerlink" title="自身浮动法"></a><span id="9">自身浮动法</span></h3>通过左右两栏浮动，中间部分自己顶上去并填满，再用BFC或者margin左右宽度去实现</li>
</ul>
<pre><code class="html">&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .div1 {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
    }
    .div3 {
        width: 200px;
        height: 200px;
        background-color: black;
        float: right;
    }
    .div2 {
        height: 300px;
        background-color: blue;
        overflow: hidden;
        /*或者通过设置左右的margin去调整*/
    }
&lt;/style&gt;
</code></pre>
<h3 id="通过设置负边距"><a href="#通过设置负边距" class="headerlink" title="通过设置负边距"></a><span id="10">通过设置负边距</span></h3><p>设置 <code>margin-left:100%</code> 能够使div1贴紧div4的左边缘，而 <code>margin-left:-200px;</code> 则会使div3贴紧右边缘，通过设置div2两侧的margin而处于合适位置。此时div1和div3仍在div4上方</p>
<pre><code class="html">&lt;div class=&quot;div4&quot;&gt;
    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .div4 {
        width: 100%;
        float: left;
    }
    .div2 {
        height: 300px;
        background-color: blue;
        margin: 0 200px;
    }
    .div1 {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
        margin-left: -100%;
    }
    .div3 {
        width: 200px;
        height: 200px;
        background-color: black;
        float: left;
        margin-left: -200px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a><span id="11">圣杯布局</span></h3><p>通过给最外层套的div设置padding，给固定尺寸的让出两侧的空间，再让内部的都浮动起来，然后固定尺寸的通过负边距调整。左侧的先通过 <code>margin-left:-100%;</code> 来调到左侧，再通过相对定位挪到之前 <code>padding</code> 腾出来的空间。而右侧则利用 <code>margin-right</code> 为自身宽度的方法，使自己宽度缩为0，从而挪上去。</p>
<p>圣杯布局优点：</p>
<blockquote>
<ul>
<li>两边带有固定宽度中间可以流动（fluid）；</li>
<li>允许中间一栏最先出现；</li>
<li>允许任意一栏放在最上面；</li>
<li>仅需一个额外的 div 标签</li>
<li>仅需非常简单的 CSS，带上最少的兼容性补丁</li>
</ul>
</blockquote>
<pre><code class="html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .container {
        padding: 0 300px 0 200px;
    }
    .container:after {
        content: &quot;&quot;;
        display: table;
        clear: both;
    }
    .main {
        width: 100%;
        height: 300px;
        background-color: blue;
        float: left;
    }
    .left {
        width: 200px;
        height: 200px;
        background-color: red;
        float: left;
        margin-left: -100%;
        right: 200px;
        position: relative;
    }
    .right {
        width: 300px;
        height: 200px;
        background-color: black;
        float: left;
        margin-right: -300px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a><span id="12">双飞翼布局</span></h3><p>先让肢体摆好，然后插翅膀，再把关键部位摆放好。基本的一些思路跟圣杯布局很像</p>
<pre><code class="html">&lt;div class=&quot;middle&quot;&gt;
    &lt;div class=&quot;middle-2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .middle{
        width: 100%;
        height: 300px;
        float: left;
    }
    .left {
        width: 300px;
        height: 300px;
        background-color: green;
        float: left;
        margin-left: -100%;
        position: relative;
    }
    .right {
        width: 200px;
        height: 200px;
        background-color: blue;
        float: left;
        margin-left: -200px;
        position: relative;
    }
    .middle-2 {
        margin: 0 200px 0 300px;
        background-color: red;
    }
&lt;/style&gt;
</code></pre>
<h3 id="右栏固定宽度，左栏自适应的布局"><a href="#右栏固定宽度，左栏自适应的布局" class="headerlink" title="右栏固定宽度，左栏自适应的布局"></a><span id="1">右栏固定宽度，左栏自适应的布局</span></h3><p>在做下一个的时候，用自己想的一个方法去实现的话感觉还是有必要写一下这个类型</p>
<pre><code class="html">&lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
    .main:after {
        content: &quot;&quot;;
        display: table;
        clear: both;
    }
    .left {
        width: 100%;
        height: 200px;
        float: left;
        background-color: blue;
    }
    .right {
        float: left;
        width: 300px;
        height: 300px;
        background-color: red;
        margin-left: -300px;
    }
&lt;/style&gt;
</code></pre>
<h3 id="中间宽度固定，左右自适应的布局"><a href="#中间宽度固定，左右自适应的布局" class="headerlink" title="中间宽度固定，左右自适应的布局"></a><span id="13">中间宽度固定，左右自适应的布局</span></h3><p>在搜索资料的时候偶然看见了这种布局要求，顺便也整理一下</p>
<pre><code class="html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    .main {
        width: 300px;
        height: 200px;
        overflow: hidden;
        background-color: blue;
        float: left;
    }
    .left {
        /*width: 50%;*/
        height: 240px;
        background-color: red;

    }
    .right {
        /*width: 50%;*/
        height: 350px;
        background-color: black;

    }
&lt;/style&gt;
</code></pre>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.zhihu.com/question/21679928" target="_blank" rel="external">流布局与响应式网页设计有什么区别？</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2010/01/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%80%9D%E6%83%B3%E6%B5%85%E8%AE%AE-%E6%B7%98%E5%AE%9D%E6%96%B0%E7%89%88%E9%A6%96%E9%A1%B5%E4%B8%BA%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">网页布局思想浅议-淘宝新版首页为实例</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2011/09/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80/" target="_blank" rel="external">应运而生的web页面响应布局</a></li>
<li><a href="http://luopq.com/2015/11/08/CSS-float/" target="_blank" rel="external">详解CSS float属性</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">前端精选文摘：BFC 神奇背后的原理</a></li>
<li><a href="http://www.html-js.com/article/1866" target="_blank" rel="external">CSS之BFC详解</a></li>
<li><a href="http://www.w3cplus.com/blog/104.html" target="_blank" rel="external">CSS三栏布局——中间固定两边自适应宽度</a></li>
<li><a href="https://segmentfault.com/a/1190000004524159" target="_blank" rel="external">关于「圣杯布局」</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉好久没咋写过样式了，手有些生，顺便借整理的机会熟悉一下&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://regiondavid.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="整理归纳" scheme="http://regiondavid.github.io/blog/tags/%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>知识点记录</title>
    <link href="http://regiondavid.github.io/blog/2016/10/20/%E4%B8%80%E7%82%B9%E5%B0%8F%E4%B8%9C%E8%A5%BF/"/>
    <id>http://regiondavid.github.io/blog/2016/10/20/一点小东西/</id>
    <published>2016-10-20T08:30:00.000Z</published>
    <updated>2016-10-27T08:57:23.599Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己平时学习过程中忽视的或者遗忘的知识点<br><a id="more"></a></p>
<h4 id="return-a-amp-amp-b"><a href="#return-a-amp-amp-b" class="headerlink" title="return a &amp;&amp; b;"></a>return a &amp;&amp; b;</h4><p>if(a){<br>    return b;<br>} else return a;</p>
<h4 id="return-a-b"><a href="#return-a-b" class="headerlink" title="return a || b;"></a>return a || b;</h4><p>if(a){<br>    return a;<br>} else return b;</p>
<blockquote>
<p>As defined in the method signature, you will have to return a boolean. Therefore, after the return keyword, you will have to provide a boolean or an expression which is evaluated to boolean</p>
<p>In your case you have the expession (subTree(t1.left, t2) || subTree(t1.right, t2)); in which the two operands will be evaluated to boolean and you will apply an logical OR on them only if the first evaluates to false. If the first operand evaluates to true the second will not be evaluated and true will be retured.</p>
</blockquote>
<p>也就是说return是要返回一个布尔值或者能够决定这个表达式布尔值的关键因素</p>
<p>参考 <a href="http://stackoverflow.com/questions/21556993/java-in-return-statements" target="_blank" rel="external">回答一</a> <a href="http://stackoverflow.com/questions/4490274/returning-with" target="_blank" rel="external">回答二</a> <a href="http://stackoverflow.com/questions/5417969/why-dont-logical-operators-and-always-return-a-boolean-result" target="_blank" rel="external">回答三</a></p>
<h4 id="String-prototype-split-str"><a href="#String-prototype-split-str" class="headerlink" title="String.prototype.split(str)"></a>String.prototype.split(str)</h4><ul>
<li>字符串中如果有指定的str字符串，就把原字符串从这个地方截断，并依次存在新数组中再返回</li>
</ul>
<p>eg:</p>
<pre><code class="js">var str1 = &quot;ssxs:xsfas&quot;;str1.split(&quot;:&quot;);//[&quot;ssxs&quot;,&quot;xsfas&quot;]
</code></pre>
<ul>
<li>如果字符串中没有指定str字符串，就会把整个字符串存在一个新数组中再返回<br>eg:</li>
</ul>
<pre><code class="js">var str2 = &quot;ageafaefe&quot;;
str2.split(&quot;:&quot;);
//[&quot;ageafaefe&quot;]
</code></pre>
<ul>
<li>如果字符串中有不止一个指定的str字符串，那么会在每个符合str字符串的地方截断，依次拼成一个数组再返回<br>eg:<pre><code class="js">var str3 = &quot;qq:ff:gg&quot;;
str3.split(&quot;:&quot;);
//[&quot;qq&quot;,&quot;ff&quot;,&quot;gg&quot;]
</code></pre>
<h4 id="position-absolute之后，默认不是顶到左上角，而是保持在原来位置"><a href="#position-absolute之后，默认不是顶到左上角，而是保持在原来位置" class="headerlink" title="position:absolute之后，默认不是顶到左上角，而是保持在原来位置"></a><code>position:absolute</code>之后，默认不是顶到左上角，而是保持在原来位置</h4><h4 id="两个-div-都-display-inline-block-之后，中间有间隙"><a href="#两个-div-都-display-inline-block-之后，中间有间隙" class="headerlink" title="两个 div 都 display: inline-block 之后，中间有间隙"></a>两个 div 都 <code>display: inline-block</code> 之后，中间有间隙</h4>此处的空隙就是代码之间的换行符（有说空格符）的空隙</li>
</ul>
<h5 id="消除办法"><a href="#消除办法" class="headerlink" title="消除办法"></a>消除办法</h5><ul>
<li>可以把源代码放到一行去</li>
<li>把字符设置成0px的大小：<code>font-size:0;</code>  缺点：据说在IE7下有1px的空隙，顺便更正张鑫旭博文中的一点，目前chrome已经支持 <code>font-size:0</code> 了，可以放心使用；</li>
<li>使用<code>letter-spaceing: -4px;</code> 去设置字符间的间距。至于具体的设置多少还是要去看使用的字体，比如我测试的时候，设置了-10px才起作用。</li>
</ul>
<p>参考 <a href="http://www.zhangxinxu.com/wordpress/2010/11/%E6%8B%9C%E6%8B%9C%E4%BA%86%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80-%E5%9F%BA%E4%BA%8Edisplayinline-block%E7%9A%84%E5%88%97%E8%A1%A8%E5%B8%83%E5%B1%80/" target="_blank" rel="external">张鑫旭的这篇文章</a>的第五部分</p>
<h3 id="第一个div浮动之后，第二个div默认宽度是100-；"><a href="#第一个div浮动之后，第二个div默认宽度是100-；" class="headerlink" title="第一个div浮动之后，第二个div默认宽度是100%；"></a>第一个div浮动之后，第二个div默认宽度是100%；</h3><p>eg:</p>
<pre><code class="html">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;style&gt;
    #div1{
        float:left;
    }
    #div2{
        height: 200px;
        background-color: red;
    }
&lt;/style&gt;
</code></pre>
<p>上述代码会出现这种效果<br><img src="http://p1.bpimg.com/1949/bee747d7df63c4da.png" alt="Markdown"><br>因为div的默认宽度都是自适应的100%，而且浮动会创建一个BFC，BFC对外界元素是没有影响的，同时会根据方向紧靠对应的边缘，这就是div1会贴在左边缘的原因，而div2则占据了剩下的所有空间，在二列布局中，我们除了让div2通过 <code>margin-left</code> 的方式去跟div1并列之外，也可以让div2也变成一个BFC，这样就可以并列在一起了，因为BFC不会与浮动盒子叠加。</p>
<p>另：块级元素默认宽度是100%；只设置高度即可。</p>
<h4 id="css-中-left、right、top、bottom-的使用"><a href="#css-中-left、right、top、bottom-的使用" class="headerlink" title="css 中 left、right、top、bottom 的使用"></a><code>css</code> 中 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 的使用</h4><h4 id="如何遍历一个对象"><a href="#如何遍历一个对象" class="headerlink" title="如何遍历一个对象"></a>如何遍历一个对象</h4><ul>
<li>Object.keys(obj)</li>
<li>for-in loop</li>
<li>map</li>
</ul>
<blockquote>
<p>the difference being that a for-in loop enumerates properties in the prototype chain as well</p>
</blockquote>
<p>参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">Object.keys</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录自己平时学习过程中忽视的或者遗忘的知识点&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://regiondavid.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="整理归纳" scheme="http://regiondavid.github.io/blog/tags/%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>代理模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/10/19/代理模式学习笔记/</id>
    <published>2016-10-19T12:30:00.000Z</published>
    <updated>2016-10-27T08:58:45.303Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式<br><a id="more"></a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
</blockquote>
<ul>
<li>小明追MM的例子<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39;+flower);
  }
};
xiaoming.sendFlower(A);
</code></pre>
添加代理B<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var B = {
  receiveFlower: function(flower){
      A.receiveFlower(flower);
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39;+flower);
  }
};
xiaoming.sendFlower(B);
</code></pre>
添加B监听A<pre><code class="js">var Flower = function(){};
var xiaoming = {
  sendFlower: function(target){
      var flower = new Flower();
      target.receiveFlower(flower);
  }
};
var B = {
  receiveFlower: function(flower){
      A.listenGoodMood(function(){
          A.receiveFlower(flower);
      })
  }
};
var A = {
  receiveFlower: function(flower){
      console.log(&#39;收到花&#39; + flower);
  },
  listenGoodMood: function(fn){
      setTimeout(function(){
          fn();
      },10000);
  }
};
xiaoming.sendFlower(B);
</code></pre>
</li>
<li>保护代理和虚拟代理<ul>
<li>保护代理：<blockquote>
<p>代理B可以帮助A过滤掉一些请求。这些请求可以直接在代理B处理时被拒绝掉。</p>
</blockquote>
</li>
<li>虚拟代理：<blockquote>
<p>把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>eg:</p>
<pre><code class="js">var B = {
    receiveFlower: function(flower){
        A.listenGoodMood(function(){
            var flower = new Flower();
            A.receiveFlower(flower);
        })
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>策略模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/19/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://regiondavid.github.io/blog/2016/10/19/策略模式/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2016-10-20T01:21:42.210Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式学习笔记<br><a id="more"></a></p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote>
<p>定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。</p>
</blockquote>
<p>可以理解为把目标相同的算法封装到一个策略对象中，然后去给定参数去调用。</p>
<p>将不变的和变的隔离开</p>
<ul>
<li>一个传统的demo<pre><code class="js">  var performanceS = function(){};
  performanceS.prototype.calculate = function(salary){
      return salary*4;
  }
  var performanceA = function(){};
  performanceA.prototype.calculate = function(salary){
      return salary*2;
  }
  var performanceB = function(){};
  performanceB.prototype.calculate = function(salary){
      return salary*1;
  }
  var Bonus = function(){
      this.salary = null;
      this.strategy = null;
  }
  Bonus.prototype.setSalary = function(salary){
      this.salary = salary;
  }
  Bonus.prototype.setStrategy = function(strategy){
      this.strategy = strategy;
  }
  Bonus.prototype.getBonus = function(){
      return this.strategy.calculate(this.salary);
  }
</code></pre>
</li>
<li>一个js版的demo<blockquote>
<p>因为js中函数也是对象</p>
<pre><code class="js">  var strategies = {
      &quot;S&quot;: function(salary){
          return salary*4;
      },
      &quot;A&quot;: function(salary){
          return salary*2;
      },
      &quot;B&quot;: function(salary){
          return salary*1;
      }
  }
  var caculateBonus = function(level,salary){
      return strategies[level](salary);
  };
</code></pre>
</blockquote>
</li>
<li>策略模式在动画中的运用<pre><code class="js">//计算小球当前的位置
var tween = {
  //t:已消耗时间
  //b:初始位置
  //c:目标位置
  //d:持续时间
  linear: function(t,b,c,d){
      retrun c*t/d+b;
  },
  easeIn: function(t,b,c,d){
      return c*(t/=d)*t+b;
  },
  strongEaseIn: function(t,b,c,d){
      return c*(t/=d)*t*t*t*t+b;
  },
  strongEaseOut: function(t,b,c,d){
      return c*((t=t/d-1)*t*t*t*t+1)+b;
  }，
  sineaseIn:  function(t,b,c,d){
      return c*(t/=d)*t*t+b;
  },
  sineaseOut: function(t,b,c,d){
      return c*((t=t/d-1)*t*t+1)+b;
  }
};
</code></pre>
<pre><code class="html">&lt;body&gt;
  &lt;div style=&quot;position:absolute;background:blue&quot; id=&quot;test&quot;&gt;这是测试动画div&lt;/div&gt;
&lt;/body&gt;
</code></pre>
```js<br>var Amimate = function(dom){<br>  this.dom = dom;            //进行运动的dom节点<br>  this.startTime = 0;            //动画开始时间<br>  this.startPos = 0;            //动画开始时，dom节点的位置，即dom的初始位置<br>  this.endPos = 0;            //动画结束时，dom节点的位置，即dom的目标位置<br>  this.propertyName = null;    //dom节点需要被改变的css属性名<br>  this.easing = null;            //缓动算法<br>  this.duration = null;        //动画持续时间<br>}</li>
</ul>
<p>Anitmate.prototype.start = function(propertyName,endPos,duration,easing){<br>    this.startTime = +new Date;<br>    this.startPos = this.dom.getBoundingClientRect()[propertyName];<br>    this.endPos = endPos;<br>    this.duration = duration;<br>    this.easing = tween[easing];</p>
<pre><code>var self = this;
var timeId = setInterval(function(){
    if(self.step() === false){
        clearInterval(timeId);
    }
},19);
</code></pre><p>};</p>
<p>Animate.prototype.step = function(){<br>    var t = +new Date();<br>    if(t&gt;=this.startTime + this.duration){<br>        this.update(this.endPos);<br>        return false;<br>    }<br>    var pos = this.easing(t-this.startTime,this.startPos,this.endPos - this.startPos,this.duration);<br>    this.update(pos);<br>}</p>
<p>Aniamte.prototype.update = function(pos){<br>    this.dom.style[this.propertyName] = pos+’px’;<br>};</p>
<pre><code>&gt; 我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。

- 使用策略模式检验表单
```js
var strategies = {
    isNonEmpty: function(value,errorMsg){
        if(value === &#39;&#39;){
            return errorMsg;
        }
    },
    minLength: function(value,length,errorMsg){
        if(value.length &lt; length){
            return errorMsg;
        }
    },
    isMobile: function(value,errorMsg){
        if(!/(^1[3|5|8|9][0-9]{9}$)/).test(value){
            return errorMsg;
        }
    }
}

//创建一个validator类
function Validator(){
    this.cache = [];
}
Validator.prototype.add = function(dom,rules){
    var self = this;
    for(vsr i = 0,rule;rule = rules[i++];){
        (function(rule){
            var strategyAry = rule.strategy.split(&#39;:&#39;);
            var errorMsg = rule.errorMsg;
            self.cache.push(function(){
                var strategy = strategyAry.shift();
                strategyAry.unshift(dom.value);
                strategyAry.push(errorMsg);
                return strategied[strategy].apply(dom,strategyAry);
            });
        })(rule)
    }
}
Validator.prototype.start = function(){
    for(var i=0,validatorFunc;validatorFunc = this.cache[i++];){
        var msg = validatorFunc();
        if(msg){
            return msg;
        }
    }
}
</code></pre><ul>
<li>策略模式优缺点<ul>
<li>优点<blockquote>
<p>可以避免很多<code>if-else</code>语句；便于后期的维护和扩展；strategies可复用；</p>
</blockquote>
</li>
<li>缺点<blockquote>
<p>strategies会暴露所有的方法 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://regiondavid.github.io/blog/2016/10/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://regiondavid.github.io/blog/2016/10/14/单例模式/</id>
    <published>2016-10-14T07:30:00.000Z</published>
    <updated>2016-10-19T08:51:57.938Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式学习笔记<br><a id="more"></a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<blockquote>
<p>因为JavaScript本身就是无类的，既然我们只需要一个“唯一”的对象，为什么要先为它创建一个“类”呢？更加需要</p>
</blockquote>
<p>所以单例模式其实更加需要注意的是全局变量的污染。<br>常用在只需要绑定一次的代码或者只生成一个对象上，类似JQ的one</p>
<ul>
<li><p>简单demo</p>
<pre><code class="js">  var Singleton = function(name){
      this.name = name;
      this.instance = null;
  };
  Singleton.prototype.getName = function(){
      console.log(this.name);
  };
  Singleton.getInstance = function(name){
      if(!this.instance){
          this.instance = new Singleton();
      }
      return this.instance;
  };
  var a = Singleton.getInstance(&#39;sven1&#39;);
  var b = Singleton.getInstance(&#39;sven2&#39;);

  console.log(a===b);
</code></pre>
</li>
<li>透明的单例模式<pre><code class="js">  var CreateDiv = (function(){
      var instance;
      var CreateDiv = function( html){
          if(instance) {
              return instance;
          }
          this.html = html;
          this.init();
          return instance = this;
      };
      CreateDiv.prototype.init = function(){
          var div = document.createElement(&#39;div&#39;);
          div.innerHTML = this.html;
          document.body.appendChild(div);
      };
      return CreateDiv;
  })();
  //用闭包和IIFE封装instance
  var a = new CreateDiv( &#39;&lt;p&gt;222&lt;/p&gt;&#39;);
  var b = new CreateDiv( &#39;sven2&#39;);
  console.log(a===b);
</code></pre>
</li>
<li>用代理实现单例模式<br>把判断是否有instance提取出来，方便createDiv的复用<pre><code class="js">  var CreateDiv = function(html){
      this.html = html;
      this.init();
  };
  CreateDiv.prototype.init = function(){
      var div = document.createElement(&#39;div&#39;);
      div.innerHTML = this.html;
      document.body.appendChild(div);
  }
  var ProxySingletonCreateDiv = (function(){
      var instance;
      return function(html){
          if(!instance){
              instance = new CreateDiv(html);
          }
          return instance;
      }
  })();
  var a = new ProxySingletonCreateDiv(&#39;sven1&#39;);
  var b = new ProxySingletonCreateDiv(&#39;sven2&#39;);
  console.log(a===b);
</code></pre>
</li>
<li>惰性单例<blockquote>
<p>在需要时才创建对象实例</p>
<pre><code class="js">  Singleton.getInstance = (function(){
      var instance = null;
      return function(name){
          if(!instance){
              instance = new Singleton(name);
          }
          return instance;
      }
  })();
</code></pre>
<p>将上述代码中的单例判断逻辑抽离出来</p>
<pre><code class="js">  var getSingle = function(fn){
      var result;
      return function(){
          return result || (result = fn.apply(this,arguments));    
      }
  }
</code></pre>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="http://regiondavid.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://regiondavid.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记</title>
    <link href="http://regiondavid.github.io/blog/2016/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://regiondavid.github.io/blog/2016/10/12/设计模式学习笔记/</id>
    <published>2016-10-12T01:30:00.000Z</published>
    <updated>2016-10-19T08:56:02.791Z</updated>
    
    <content type="html"><![CDATA[<p>跟着 《<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="external">JavaScript设计模式与开发实践</a>》 一书学习设计模式<br><a id="more"></a></p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="../../14/单例模式/">单例模式</a></li>
<li><a href="../../19/策略模式/">策略模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着 《&lt;a href=&quot;https://book.douban.com/subject/26382780/&quot;&gt;JavaScript设计模式与开发实践&lt;/a&gt;》 一书学习设计模式&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://regiondavid.github.io/blog/categories/code/"/>
    
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="随笔" scheme="http://regiondavid.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="note" scheme="http://regiondavid.github.io/blog/tags/note/"/>
    
      <category term="code" scheme="http://regiondavid.github.io/blog/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>盒模型的继续探索——margin属性</title>
    <link href="http://regiondavid.github.io/blog/2016/07/19/blog2/"/>
    <id>http://regiondavid.github.io/blog/2016/07/19/blog2/</id>
    <published>2016-07-19T13:41:44.000Z</published>
    <updated>2016-08-08T13:54:25.068Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们了解了盒模型的基本概念，并初步尝试了一下，结果最后留下了个问题还没解决。那么今天我们就把上次的问题解决掉，顺便研究一下盒模型中的一个重要部分——margin<br><a id="more"></a></p>
<p>####先看上次的问题：</p>
<pre><code class="html">    &lt;div id=&quot;div1&quot;&gt;
          &lt;div id=&quot;div2&quot;&gt;2333&lt;/div&gt;
    &lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #div1{
            width:500px;
            height: 300px;
            background-color: green;
        }
        #div2{
            margin-top:50px;
            padding-top: 50px;
            width:300px;
            height: 100px;
            background-color: blue;
        }
    &lt;/style&gt;
</code></pre>
<p>结果是这样的：<br><img src="http://i4.piimg.com/1949/f51c11a305253f94.png" alt="image1.png"><br>可以看到div2不仅没有和div1隔开50px的距离，反而div1和div2一起向下移动了50px，在上方空出了50px的空白，这是怎么回事？</p>
<p>首先让我们看看MDN上对margin属性的定义</p>
<blockquote>
<p>margin属性为给定元素设置所有四个（上下左右）方向的外边距属性。这是四个外边距属性设置的简写。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数。</p>
<p>形式语法:   [ <length> | <percentage> | auto ]{1,4}</percentage></length></p>
<p>margin: style                  /<em>单值语法   </em>/  举例： margin: 1em; </p>
<p>margin: vertical horizontal    /<em>二值语法   </em>/  举例： margin: 5% auto; </p>
<p>margin: top horizontal bottom  /<em>三值语法 </em>/  举例： margin: 1em auto 2em; </p>
<p>margin: top right bottom left  /<em>四值语法  </em>/  举例： margin: 2px 1em 0 auto; </p>
<p>margin: inherit</p>
</blockquote>
<p>注意：</p>
<ul>
<li>当同时为某个元素设置4个margin属性的时候，按照上右下左的顺序，为了便于记忆可以记住是顺时针顺序</li>
<li>当某个元素的margin-left和margin-right设置为auto时，一般为水平居中，这也是我们平时最常用的水平居中方法</li>
</ul>
<p>再来看一下我们之前的那个例子，其实问题很简单，就是由于margin计算的是兄弟级的盒模型，而div2就是那一级唯一的一个盒子，所以当div2向下移动了50px的时候，div1必须紧贴着div2，所以也跟着向下移动了50px。</p>
<p>如此说来，要想出现我们所需要的效果，只需要为div2添加浮动即可。比如：<code>float:left</code>。</p>
<pre><code class="css">    #div2{
            margin-top:50px;
            padding-top: 50px;
            width:300px;
            height: 100px;
            background-color: blue;
             float: left;
        }
</code></pre>
<p><img src="http://i1.piimg.com/1949/10abbd886ca3fedd.png" alt="image2"></p>
<h3 id="扩展：外边距塌陷"><a href="#扩展：外边距塌陷" class="headerlink" title="扩展：外边距塌陷"></a>扩展：外边距塌陷</h3><p>在MDN上有着明确的定义</p>
<blockquote>
<p>块元素的 top 与 bottom 外边距有时会合并（塌陷）为单个外边距（合并后最大的外边距），这样的现象称之为 外边距合并(塌陷)。</p>
</blockquote>
<p>下面三种基本情形会出现外边距塌陷：</p>
<ul>
<li>毗邻兄弟元素<blockquote>
<p>毗邻的兄弟元素的外边距会塌陷（当靠后的元素清除浮动时除外）</p>
</blockquote>
</li>
<li>父元素与第一个/最后一个子元素<blockquote>
<p>如果块元素的 margin-top 与它的第一个子元素的margin-top 之间没有 border、padding、inline content、 clearance 来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的margin-bottom 之间没有 border、padding、inline content、height、min-height、 max-height 分隔，那么外边距会合并(塌陷)。子元素多余的外边距会被父元素的外边距截断。</p>
</blockquote>
</li>
<li>空块元素<blockquote>
<p>如果块元素的 margin-top 与 margin-bottom 之间没有 border、padding、inline content、height、min-height 来分隔，那么它的上下外边距将会合并。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>即使外边距为0，这些规则仍旧生效。因此，无论父元素的外边距是否为0，第一个或者最后一个子元素的外边距会被父元素的外边距截断(根据上面的规则)，在负外边距的情况下，合并后的外边距为最大正外边距与最小负外边距之和。</p>
<p>浮动 及 绝对定位 元素外边距不会合并。</p>
</blockquote>
<p>关于外边距塌陷，有兴趣的同学可以自己尝试一下。</p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin" target="_blank" rel="external">margin属性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="external">外边距合并（塌陷）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次我们了解了盒模型的基本概念，并初步尝试了一下，结果最后留下了个问题还没解决。那么今天我们就把上次的问题解决掉，顺便研究一下盒模型中的一个重要部分——margin&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>盒模型的科普及一点小探索</title>
    <link href="http://regiondavid.github.io/blog/2016/07/13/blog1/"/>
    <id>http://regiondavid.github.io/blog/2016/07/13/blog1/</id>
    <published>2016-07-13T13:41:44.000Z</published>
    <updated>2016-07-30T14:09:42.054Z</updated>
    
    <content type="html"><![CDATA[<p>盒模型的科普及一点小探索<br><a id="more"></a></p>
<h3 id="什么是盒模型？"><a href="#什么是盒模型？" class="headerlink" title="什么是盒模型？"></a>什么是盒模型？</h3><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="external">MDN上的解释</a></p>
<blockquote>
<p>文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。在CSS中，这些矩形盒子用 标准盒模型 来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界margin edge, 边框边界border edge, 内边距边界padding edge 与 内容边界content edge。 </p>
</blockquote>
<p>可以看出盒模型就像它的名字那样，指的就是一个矩形盒子，但是这个盒子有外边距、内边距、边框和内容区域。如下图所示：<br><img src="http://www.w3school.com.cn/i/ct_boxmodel.gif" alt="盒模型"></p>
<p>从图可以看出，我们平时所定义的 width 和 height 都是对应的内容区域，但是当我们在布局的时候，则是依照盒模型的尺寸去进行布局。所以在最后计算的时候：<code>盒模型的宽度 = margin 的宽度 + padding 的宽度 + border 的宽度 + 内容区域的宽度</code>。<br>似乎将 padding 和 border 也计算在宽度里不大符合我们常人的思维，IE 也是这么想的。所以在 IE 下和其他浏览器下计算的尺寸是不一样的。对此，css3 提出了 box-sizing 这个属性。box-sizing 有两个可选值，一个是默认的 content-box，另一个就是 border-box。当把 box-sizing 设置为 content-box 的时候，计算尺寸就把所有的都加起来；当设置为 border-box 时，就类似IE的计算方法，将 padding 和 border 算在 width 和 height 里。掌握这些基础对页面的布局有着非常好的帮助。</p>
<h3 id="一点有趣的探索"><a href="#一点有趣的探索" class="headerlink" title="一点有趣的探索"></a>一点有趣的探索</h3><pre><code class="html">    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #div1{
            width:500px;
             height: 300px;
            background-color: green;
        }
        #div2{
            width:300px;
             height: 100px;
            background-color: blue;
        }
    &lt;/style&gt;
</code></pre>
<p>这是最初的样子<img src="http://i4.piimg.com/4851/50f5caa366cd86c5.png" alt="test1"><br>当我把css稍作修改</p>
<pre><code class="css">    #div2{
      padding-top:50px;
      width:300px;
      height: 100px;
      background-color: blue;
    }
</code></pre>
<p>结果变成了这个样子。。。<br><img src="http://i2.piimg.com/4851/aeeee223f73c2a76.png" alt="test2"><br><img src="http://www.18183.com/uploads/150805/41-150P51Q24Q15.jpg" alt="什么鬼">，div2咋还变长了？<br>于是我开始了探索(<del>瞎折腾</del>)<br>首先在div中添加几个字，看看content区域有没有变，内容区域果然正常<img src="http://i2.piimg.com/4851/86e535e23ba2bb32.png" alt="test3"><br>可以很明显对比看到内容区域向下移动了50px的距离，但是为什么内容的上方仍然是蓝色呢？<br>还记得我们开头的话吗？</p>
<blockquote>
<p>文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。</p>
</blockquote>
<p>而这里渲染的背景颜色就是基于盒模型去渲染的，它会把padding部分和content部分都去渲染上背景色。<br>那么问题又来了，如果再设置margin属性，背景色会不会也渲染上呢？</p>
<pre><code class="css">    #div2{
      margin-top:50px;
      padding-top:50px;
      width:300px;
      height: 100px;
      background-color: blue;
    }
</code></pre>
<p>渲染出来的结果竟然是<img src="http://i2.piimg.com/4851/e5299204e93b1362.png" alt="test4"><br>结果div2的背景色不仅没有变化，div1上边竟然还多出一块空白的？！<br><img src="http://easyread.ph.126.net/4r1X30AHvtnDORiKVCvsHw==/7916690428175172728.jpg" alt="WTF"></p>
<p>这他喵的是咋回事？</p>
<p>预知后事如何，且听下回分解</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒模型的科普及一点小探索&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://regiondavid.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
